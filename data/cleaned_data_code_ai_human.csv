text,ai
"public class Solution {
    public int maxSum(int[] nums) {
        int[] maxSum = new int[10];
        for (int num : nums) {
            int maxDigit = 0;
            int temp = num;
            while (temp > 0) {
                maxDigit = Math.max(maxDigit, temp % 10);
                temp /= 10;
            }
            for (int i = 0; i < 10; i++) {
                if (i == maxDigit) {
                    maxSum[i] = Math.max(maxSum[i], num + maxSum[i]);
                } else {
                    maxSum[i] = Math.max(maxSum[i], num);
                }
            }
        }
        int res = -1;
        for (int sum : maxSum) {
            res = Math.max(res, sum);
        }
        return res == 0 ? -1 : res;
    }
}",1
"class Solution:
    def maxSum(self, nums: List[int]) -> int:
        max_digit = {}
        for num in nums:
            digit = max(int(d) for d in str(num))
            if digit not in max_digit:
                max_digit[digit] = []
            max_digit[digit].append(num)
        res = -1
        for digit, values in max_digit.items():
            if len(values) >= 2:
                values.sort(reverse=True)
                res = max(res, values[0] + values[1])
        return res",1
"class Solution {
public:
    int maxSum(std::vector<int>& nums) {
        int maxSum = -1;
        for (int i = 0; i < nums.size(); i++) {
            for (int j = i + 1; j < nums.size(); j++) {
                if (maxDigit(nums[i]) == maxDigit(nums[j])) {
                    maxSum = std::max(maxSum, nums[i] + nums[j]);
                }
            }
        }
        return maxSum;
    }

private:
    int maxDigit(int num) {
        int maxDigit = 0;
        while (num > 0) {
            maxDigit = std::max(maxDigit, num % 10);
            num /= 10;
        }
        return maxDigit;
    }
};",1
"class Solution {
    public String finalString(String s) {
        StringBuilder sb = new StringBuilder();
        for (char c : s.toCharArray()) {
            if (c == 'i') {
                sb.reverse();
            } else {
                sb.append(c);
            }
        }
        return sb.toString();
    }
}",1
"class Solution:
    def finalString(self, s: str) -> str:
        res = """"
        for c in s:
            if c == 'i':
                res = res[::-1]
            else:
                res += c
        return res",1
"class Solution {
public:
    std::string finalString(std::string s) {
        std::string result = """";
        for (char c : s) {
            if (c == 'i') {
                std::reverse(result.begin(), result.end());
            } else {
                result += c;
            }
        }
        return result;
    }
};",1
"public class Solution {
    public int minAbsoluteDifference(List<Integer> nums, int x) {
        TreeMap<Integer, Integer> map = new TreeMap<>();
        map.put(nums.get(0), 0);
        int n = nums.size();
        int minDiff = Integer.MAX_VALUE;

        for (int i = 1; i < n; i++) {
            if (i >= x) {
                map.remove(nums.get(i - x));
            }
            Integer lower = map.floorKey(nums.get(i));
            Integer higher = map.ceilingKey(nums.get(i));
            if (lower != null) {
                minDiff = Math.min(minDiff, Math.abs(nums.get(i) - lower));
            }
            if (higher != null) {
                minDiff = Math.min(minDiff, Math.abs(nums.get(i) - higher));
            }
            map.put(nums.get(i), i);
        }

        return minDiff;
    }
}",1
"class Solution:
    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:
        n = len(nums)
        min_diff = float('inf')
        for i in range(n):
            for j in range(i + x, n):
                min_diff = min(min_diff, abs(nums[i] - nums[j]))
        return min_diff",1
"class Solution {
public:
    int minAbsoluteDifference(std::vector<int>& nums, int x) {
        int minDiff = INT_MAX;
        for (int i = 0; i < nums.size(); i++) {
            for (int j = i + x; j < nums.size(); j++) {
                minDiff = std::min(minDiff, std::abs(nums[i] - nums[j]));
            }
        }
        return minDiff;
    }
};",1
"class Solution {
    public ListNode doubleIt(ListNode head) {
        // Convert linked list to number
        long num = 0;
        while (head != null) {
            num = num * 10 + head.val;
            head = head.next;
        }

        // Double the number
        num *= 2;

        // Convert number back to linked list
        ListNode dummy = new ListNode(0);
        ListNode curr = dummy;
        do {
            curr.next = new ListNode((int)(num % 10));
            num /= 10;
            curr = curr.next;
        } while (num > 0);

        // Reverse the linked list and return
        return reverse(dummy.next);
    }

    private ListNode reverse(ListNode head) {
        ListNode prev = null;
        while (head != null) {
            ListNode next = head.next;
            head.next = prev;
            prev = head;
            head = next;
        }
        return prev;
    }
}",1
"class Solution:
    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # Convert linked list to integer
        num = 0
        curr = head
        while curr:
            num = num * 10 + curr.val
            curr = curr.next

        # Double the integer
        num *= 2

        # Convert integer to linked list
        dummy = ListNode(0)
        curr = dummy
        for digit in str(num):
            curr.next = ListNode(int(digit))
            curr = curr.next

        return dummy.next",1
"class Solution {
public:
    ListNode* doubleIt(ListNode* head) {
        ListNode* current = head;
        int carry = 0;
        while (current != nullptr) {
            int sum = current->val * 2 + carry;
            current->val = sum % 10;
            carry = sum / 10;
            if (current->next == nullptr && carry > 0) {
                current->next = new ListNode(carry);
                break;
            }
            current = current->next;
        }
        return head;
    }
};",1
"public class Solution {
    private static final int MOD = 1_000_000_007;
    private List<Integer> nums;
    private int n;
    private List<Integer>[] factors;

    public int maximumScore(List<Integer> nums, int k) {
        this.nums = nums;
        this.n = nums.size();
        this.factors = new ArrayList[n];
        for (int i = 0; i < n; i++) {
            factors[i] = primeFactors(nums.get(i));
        }

        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[2] - a[2]);
        pq.offer(new int[]{0, n - 1, maxPrimeScore(0, n - 1)});

        long res = 1;
        boolean[] chosen = new boolean[n];
        while (k-- > 0) {
            int[] cur = pq.poll();
            int l = cur[0], r = cur[1], maxScore = cur[2];
            res = (res * maxScore) % MOD;

            int maxIdx = maxPrimeScoreIndex(l, r);
            chosen[maxIdx] = true;

            if (maxIdx - 1 >= l && !chosen[maxIdx - 1]) {
                pq.offer(new int[]{l, maxIdx - 1, maxPrimeScore(l, maxIdx - 1)});
            }
            if (maxIdx + 1 <= r && !chosen[maxIdx + 1]) {
                pq.offer(new int[]{maxIdx + 1, r, maxPrimeScore(maxIdx + 1, r)});
            }
        }

        return (int) res;
    }

    private List<Integer> primeFactors(int num) {
        List<Integer> factors = new ArrayList<>();
        for (int i = 2; i * i <= num; i++) {
            if (num % i == 0) {
                factors.add(i);
                while (num % i == 0) {
                    num /= i;
                }
            }
        }
        if (num > 1) {
            factors.add(num);
        }
        return factors;
    }

    private int maxPrimeScore(int l, int r) {
        int maxScore = 0;
        for (int i = l; i <= r; i++) {
            maxScore = Math.max(maxScore, factors[i].size());
        }
        return maxScore;
    }

    private int maxPrimeScoreIndex(int l, int r) {
        int maxScore = 0, idx = -1;
        for (int i = l; i <= r; i++) {
            if (factors[i].size() >= maxScore) {
                maxScore = factors[i].size();
                idx = i;
            }
        }
        return idx;
    }
}",1
"class Solution:
    def maximumScore(self, nums: List[int], k: int) -> int:
        n = len(nums)
        MOD = 10**9 + 7

        # Precompute the prime score of all numbers in nums
        prime_score = [0] * n
        for i, num in enumerate(nums):
            for j in range(2, int(sqrt(num)) + 1):
                if num % j == 0:
                    prime_score[i] += 1
                    while num % j == 0:
                        num //= j
            if num > 1:
                prime_score[i] += 1

        # Compute the maximum score using dynamic programming
        dp = [1]
        for _ in range(k):
            new_dp = [0] * (n + 1)
            for l in range(n):
                for r in range(l, n):
                    max_prime_score = max(prime_score[l:r+1])
                    max_index = prime_score[l:r+1].index(max_prime_score) + l
                    new_dp[r+1] = max(new_dp[r+1], dp[l] * nums[max_index] % MOD)
            dp = new_dp

        return max(dp) % MOD",1
"class Solution {
public:
    int maximumScore(std::vector<int>& nums, int k) {
        const int MOD = 1e9 + 7;
        int n = nums.size();
        std::vector<int> primeScore(n);
        for (int i = 0; i < n; i++) {
            primeScore[i] = getPrimeScore(nums[i]);
        }
        std::vector<std::vector<long long>> dp(n, std::vector<long long>(k + 1));
        for (int i = 0; i < n; i++) {
            dp[i][0] = nums[i];
            for (int j = 1; j <= k; j++) {
                for (int l = 0; l < i; l++) {
                    if (primeScore[l] >= primeScore[i]) {
                        dp[i][j] = std::max(dp[i][j], dp[l][j - 1] * nums[i] % MOD);
                    }
                }
            }
        }
        long long maxScore = 0;
        for (int i = 0; i < n; i++) {
            maxScore = std::max(maxScore, dp[i][k]);
        }
        return maxScore % MOD;
    }

private:
    int getPrimeScore(int num) {
        int score = 0;
        for (int i = 2; i <= std::sqrt(num); i++) {
            if (num % i == 0) {
                score++;
                while (num % i == 0) {
                    num /= i;
                }
            }
        }
        if (num > 1) {
            score++;
        }
        return score;
    }
};",1
"class Solution {
    private static final int MOD = 1_000_000_007;

    public int findMaximumElegance(int[][] items, int k) {
        int n = items.length;
        List<int[]>[] categoryItems = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            categoryItems[i] = new ArrayList<>();
        }
        for (int[] item : items) {
            categoryItems[item[1]].add(item);
        }

        PriorityQueue<Integer> pq = new PriorityQueue<>();
        long[] dp = new long[k + 1];
        dp[0] = 0;
        int totalItems = 0;
        for (List<int[]> itemList : categoryItems) {
            if (itemList.isEmpty()) continue;

            Collections.sort(itemList, Comparator.comparingInt(a -> -a[0]));
            int categoryProfit = 0;
            for (int[] item : itemList) {
                categoryProfit += item[0];
                pq.offer(item[0]);
                if (pq.size() > totalItems + 1) {
                    categoryProfit -= pq.poll();
                }
            }

            for (int j = Math.min(k, totalItems + itemList.size()); j >= 0; j--) {
                for (int l = Math.max(0, j - totalItems); l <= Math.min(j, itemList.size()); l++) {
                    dp[j] = Math.max(dp[j], (j - l > 0 ? dp[j - l - 1] : 0) + categoryProfit);
                }
            }

            totalItems += itemList.size();
        }

        long res = 0;
        for (int i = 1; i <= k; i++) {
            res = Math.max(res, dp[i] + (long)i * i);
        }

        return (int)(res % MOD);
    }
}",1
"class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        n = len(items)
        items.sort(key=lambda x: (-x[0], x[1]))
        dp = [[0, 0] for _ in range(n + 1)]
        for i in range(1, n + 1):
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1])
            dp[i][1] = max(dp[i - 1][0] + items[i - 1][0], dp[i - 1][1] + items[i - 1][0])
        return max(dp[k]) + len(set([item[1] for item in items[:k]])) ** 2",1
"class Solution {
public:
    long long findMaximumElegance(std::vector<std::vector<int>>& items, int k) {
        const int MOD = 1e9 + 7;
        int n = items.size();
        std::vector<std::unordered_map<int, long long>> dp(n);
        for (int i = 0; i < n; i++) {
            dp[i][1 << items[i][1]] = items[i][0];
            for (int j = 0; j < i; j++) {
                for (auto& [mask, val] : dp[j]) {
                    int newMask = mask | (1 << items[i][1]);
                    dp[i][newMask] = std::max(dp[i][newMask], val + items[i][0]);
                }
            }
        }
        long long maxElegance = 0;
        for (int i = 0; i < n; i++) {
            for (auto& [mask, val] : dp[i]) {
                int cnt = __builtin_popcount(mask);
                if (cnt >= k) {
                    maxElegance = std::max(maxElegance, val + cnt * cnt);
                }
            }
        }
        return maxElegance % MOD;
    }
};",1
"public class Solution {
    public int maxSum(int[] nums) {
        // Create an array of size 10 to keep track of the maximum values for each digit (0-9)
        int[] maxDigits = new int[10];
        
        // Iterate through the array and update the maxDigits array with the maximum values for each digit
        for (int num : nums) {
            int maxDigit = getMaxDigit(num);
            maxDigits[maxDigit] = Math.max(maxDigits[maxDigit], num);
        }
        
        int maxSum = -1;
        
        // Iterate through the maxDigits array to find pairs with equal maximum digits
        for (int i = 0; i <= 9; i++) {
            for (int j = i; j <= 9; j++) {
                if (maxDigits[i] != 0 && maxDigits[j] != 0 && i == j) {
                    maxSum = Math.max(maxSum, maxDigits[i] + maxDigits[j]);
                }
            }
        }
        
        return maxSum;
    }
    
    // Helper method to get the maximum digit from a number
    private int getMaxDigit(int num) {
        int maxDigit = 0;
        while (num > 0) {
            maxDigit = Math.max(maxDigit, num % 10);
            num /= 10;
        }
        return maxDigit;
    }
    
}",1
"class Solution:
    def maxSum(self, nums: List[int]) -> int:
        max_digit_sum = {}  # Dictionary to store the maximum sum for each maximum digit
        
        for num in nums:
            max_digit = max(str(num))  # Find the maximum digit in the current number
            if max_digit in max_digit_sum:
                max_digit_sum[max_digit] = max(max_digit_sum[max_digit], num)
            else:
                max_digit_sum[max_digit] = num
        
        max_sum = -1  # Initialize the maximum sum to -1
        
        # Iterate through the dictionary to find the maximum sum
        for digit, num in max_digit_sum.items():
            if max_digit_sum[digit] != num:
                max_sum = max(max_sum, num + max_digit_sum[digit])
        
        return max_sum",1
"class Solution {
public:
    int maxSum(std::vector<int>& nums) {
        std::vector<int> maxDigit(10, -1); // To store the maximum number for each digit (0-9)
        int maxSum = -1; // Initialize maxSum to -1 as the minimum possible answer
        
        for (int num : nums) {
            int maxDig = 0; // To store the maximum digit in the current number
            int temp = num; // Temporary variable to avoid modifying num
            
            while (temp > 0) {
                int digit = temp % 10;
                maxDig = std::max(maxDig, digit); // Update maxDig if a larger digit is found
                temp /= 10;
            }
            
            if (maxDigit[maxDig] != -1) {
                // If we have seen a number with the same maximum digit before, update maxSum
                maxSum = std::max(maxSum, maxDigit[maxDig] + num);
            }
            
            // Update maxDigit[maxDig] with the maximum of the current number and the previous maximum
            maxDigit[maxDig] = std::max(maxDigit[maxDig], num);
        }
        
        return maxSum;
    }
};",1
"public class Solution {
    public String finalString(String s) {
        StringBuilder result = new StringBuilder();
        StringBuilder reverseBuffer = new StringBuilder();
        
        boolean reverse = false;
        
        for (char c : s.toCharArray()) {
            if (c == 'i') {
                reverse = !reverse;
            } else {
                if (reverse) {
                    reverseBuffer.insert(0, c);
                } else {
                    result.append(c);
                }
            }
        }
        
        result.append(reverseBuffer);
        
        return result.toString();
    }
    
}",1
"class Solution:
    def finalString(self, s: str) -> str:
        stack = []  # Use a stack to simulate typing process
        
        for char in s:
            if char == 'i':
                # If the character is 'i', reverse the stack
                stack.reverse()
            else:
                stack.append(char)
        
        # Convert the stack to a string and return
        return ''.join(stack)",1
"class Solution {
public:
    std::string finalString(std::string s) {
        std::string result = """"; // Initialize the result string
        
        for (char c : s) {
            if (c == 'i') {
                // If the character is 'i', reverse the result string
                std::reverse(result.begin(), result.end());
            } else {
                // Otherwise, append the character to the result string
                result += c;
            }
        }
        
        return result;
    }
};",1
"public class Solution {
    public int minAbsoluteDifference(List<Integer> nums, int x) {
        int n = nums.size();
        int minAbsDiff = Integer.MAX_VALUE;
        
        // Create a TreeMap to store the indices of elements
        TreeMap<Integer, Integer> indexMap = new TreeMap<>();
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            
            // Check if there exists a number in the TreeMap with a difference of at least x
            // from the current number, and update the minimum absolute difference accordingly.
            Integer floorKey = indexMap.floorKey(num - x);
            if (floorKey != null) {
                int index = indexMap.get(floorKey);
                minAbsDiff = Math.min(minAbsDiff, Math.abs(num - nums.get(index)));
            }
            
            // Check if there exists a number in the TreeMap with a difference of at least x
            // from the current number, and update the minimum absolute difference accordingly.
            Integer ceilingKey = indexMap.ceilingKey(num + x);
            if (ceilingKey != null) {
                int index = indexMap.get(ceilingKey);
                minAbsDiff = Math.min(minAbsDiff, Math.abs(num - nums.get(index)));
            }
            
            // Update the index of the current number in the TreeMap.
            indexMap.put(num, i);
        }
        
        return minAbsDiff;
    }
   
}",1
"class Solution:
    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:
        nums.sort()  # Sort the input array
        
        min_diff = float('inf')  # Initialize the minimum difference to positive infinity
        
        left = 0  # Initialize the left pointer
        right = x  # Initialize the right pointer
        
        while right < len(nums):
            min_diff = min(min_diff, nums[right] - nums[left])  # Update the minimum difference
            
            left += 1  # Move the left pointer
            right += 1  # Move the right pointer
        
        return min_diff",1
"class Solution {
public:
    int minAbsoluteDifference(std::vector<int>& nums, int x) {
        int n = nums.size();
        std::vector<std::pair<int, int>> indexedNums; // Store the numbers along with their indices
        
        // Create a vector of pairs (number, index)
        for (int i = 0; i < n; ++i) {
            indexedNums.push_back({nums[i], i});
        }
        
        // Sort the vector based on numbers
        std::sort(indexedNums.begin(), indexedNums.end());
        
        int minDiff = INT_MAX; // Initialize the minimum difference to a large value
        
        // Traverse the sorted vector and find the minimum absolute difference
        for (int i = 0; i < n; ++i) {
            // Find the index of the element that is at least x indices apart
            int j = i + x;
            if (j < n) {
                int diff = abs(indexedNums[i].first - indexedNums[j].first);
                minDiff = std::min(minDiff, diff);
            }
        }
        
        return minDiff;
    }
};",1
"public class Solution {
    public ListNode doubleIt(ListNode head) {
        if (head == null) {
            return null;
        }

        int carry = 0;
        ListNode current = head;
        ListNode prev = null;

        // Traverse the list in reverse order and double the values
        while (current != null) {
            int newVal = current.val * 2 + carry;
            carry = newVal / 10;
            current.val = newVal % 10;

            prev = current;
            current = current.next;
        }

        // If there's a remaining carry, add a new node for it
        if (carry > 0) {
            ListNode newNode = new ListNode(carry);
            prev.next = newNode;
        }

        return reverseList(head);
    }

    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode current = head;

        while (current != null) {
            ListNode nextNode = current.next;
            current.next = prev;
            prev = current;
            current = nextNode;
        }

        return prev;
    }
}",1
"class Solution:
    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head:
            return None
        
        carry = 0
        current = head
        prev = None
        
        # Traverse the list in reverse order and double the values
        while current:
            newVal = current.val * 2 + carry
            carry = newVal // 10
            current.val = newVal % 10
            
            prev = current
            current = current.next
        
        # If there's a remaining carry, add a new node for it
        if carry > 0:
            newNode = ListNode(carry)
            prev.next = newNode
        
        return self.reverseList(head)
    
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        prev = None
        current = head
        
        while current:
            nextNode = current.next
            current.next = prev
            prev = current
            current = nextNode
        
        return prev",1
"class Solution {
public:
    ListNode* doubleIt(ListNode* head) {
        if (!head) {
            return nullptr;
        }

        int carry = 0;
        ListNode* current = head;
        ListNode* prev = nullptr;

        // Traverse the list in reverse order and double the values
        while (current) {
            int newVal = current->val * 2 + carry;
            carry = newVal / 10;
            current->val = newVal % 10;

            prev = current;
            current = current->next;
        }

        // If there's a remaining carry, add a new node for it
        if (carry > 0) {
            ListNode* newNode = new ListNode(carry);
            prev->next = newNode;
        }

        return reverseList(head);
    }

    ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr;
        ListNode* current = head;

        while (current) {
            ListNode* nextNode = current->next;
            current->next = prev;
            prev = current;
            current = nextNode;
        }

        return prev;
    }
};",1
"public class Solution {
    public int maximumScore(List<Integer> nums, int k) {
        int MOD = 1000000007;
        int n = nums.size();
        
        // Create an array to store the prime scores for each element.
        int[] primeScores = new int[n];
        
        // Calculate the prime scores for each element using a helper function.
        for (int i = 0; i < n; i++) {
            primeScores[i] = calculatePrimeScore(nums.get(i));
        }
        
        long score = 1L; // Initialize the score as a long integer to avoid overflow.
        
        // Create a max heap to keep track of the elements with the highest prime scores.
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> Integer.compare(primeScores[b], primeScores[a]));
        
        // Initialize the max heap with the element at index k.
        maxHeap.offer(k);
        
        // Create two arrays to keep track of the left and right boundaries of the subarray.
        int[] left = new int[n];
        int[] right = new int[n];
        
        // Initialize the left and right boundaries.
        left[k] = k;
        right[k] = k;
        
        // Perform at most k operations.
        for (int i = 0; i < k; i++) {
            int maxIndex = maxHeap.poll(); // Get the index with the highest prime score.
            
            // Calculate the new score by multiplying the current score by the selected element.
            score = (score * nums.get(maxIndex)) % MOD;
            
            // Update the left and right boundaries for the subarray.
            int newLeft = left[maxIndex] - 1;
            int newRight = right[maxIndex] + 1;
            
            // Add the new potential candidates to the max heap.
            if (newLeft >= 0) {
                maxHeap.offer(newLeft);
                left[newLeft] = newLeft;
                right[newLeft] = right[maxIndex];
            }
            if (newRight < n) {
                maxHeap.offer(newRight);
                left[newRight] = left[maxIndex];
                right[newRight] = newRight;
            }
        }
        
        return (int)score;
    }
    
    // Helper function to calculate the prime score of an integer.
    private int calculatePrimeScore(int num) {
        Set<Integer> factors = new HashSet<>();
        
        // Find prime factors of the number.
        while (num % 2 == 0) {
            factors.add(2);
            num /= 2;
        }
        
        for (int i = 3; i <= Math.sqrt(num); i += 2) {
            while (num % i == 0) {
                factors.add(i);
                num /= i;
            }
        }
        
        if (num > 2) {
            factors.add(num);
        }
        
        return factors.size();
    }
}",1
"class Solution:
    def maximumScore(self, nums: List[int], k: int) -> int:
        def prime_score(x):
            factors = set()
            while x % 2 == 0:
                factors.add(2)
                x //= 2
            for i in range(3, int(x ** 0.5) + 1, 2):
                while x % i == 0:
                    factors.add(i)
                    x //= i
            if x > 2:
                factors.add(x)
            return len(factors)
        
        max_score = 1
        MOD = 10 ** 9 + 7
        
        pq = []  # Priority queue to store elements by their prime scores
        
        for num in nums:
            heapq.heappush(pq, (-prime_score(num), num))  # Use a negative score to get the maximum prime score first
        
        while k > 0:
            prime_score, num = heapq.heappop(pq)  # Pop the element with the highest prime score
            max_score = (max_score * num) % MOD
            k -= 1
        
        return max_score",1
"class Solution {
public:
    const int MOD = 1e9 + 7;

    int maximumScore(std::vector<int>& nums, int k) {
        int n = nums.size();
        std::unordered_map<int, int> primeScore; // Map to store prime scores of elements
        int left = 0; // Left pointer of the sliding window
        long long score = 1; // Initial score
        int maxScore = 1; // Maximum score

        for (int right = 0; right < n; ++right) {
            // Calculate prime score for the new element
            int curScore = calculatePrimeScore(nums[right]);

            // Update prime score map
            primeScore[nums[right]]++;

            // Increment the score by multiplying it with the prime score
            score = (score * curScore) % MOD;

            // Check if the window size exceeds k, then we need to shrink the window
            while (right - left + 1 > k) {
                int leftElem = nums[left];
                primeScore[leftElem]--;

                // If the left element has no more occurrences in the window, remove it from the map
                if (primeScore[leftElem] == 0) {
                    primeScore.erase(leftElem);
                }

                // Move the left pointer to the right
                left++;
            }

            // Update the maximum score
            maxScore = std::max(maxScore, static_cast<int>(score));
        }

        return maxScore;
    }

    // Helper function to calculate the prime score of an integer
    int calculatePrimeScore(int x) {
        int score = 0;
        for (int i = 2; i * i <= x; ++i) {
            while (x % i == 0) {
                x /= i;
                score++;
            }
        }
        if (x > 1) {
            score++;
        }
        return score;
    }
};",1
"public class Solution {
    public int findMaximumElegance(int[][] items, int k) {
        List<int[]> itemList = new ArrayList<>();
        Map<Integer, Integer> categoryFreq = new HashMap<>();
        int totalProfit = 0;
        int distinctCategories = 0;
        int maxElegance = 0;

        for (int[] item : items) {
            itemList.add(item);
        }

        Collections.sort(itemList, (a, b) -> b[0] - a[0]); // Sort by profit in descending order

        for (int i = 0; i < itemList.size(); i++) {
            int[] item = itemList.get(i);
            int profit = item[0];
            int category = item[1];

            categoryFreq.put(category, categoryFreq.getOrDefault(category, 0) + 1);
            totalProfit += profit;

            if (categoryFreq.get(category) == 1) {
                distinctCategories++;
            }

            int elegance = totalProfit + distinctCategories * distinctCategories;
            maxElegance = Math.max(maxElegance, elegance);

            if (distinctCategories == k) {
                break; // We have reached the required number of distinct categories
            }
        }

        return maxElegance;
    }
}",1
"class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        n = len(items)
        max_elegance = 0
        
        # Generate all possible combinations of items with size k
        for combo in combinations(items, k):
            total_profit = sum(item[0] for item in combo)
            categories = [item[1] for item in combo]
            distinct_categories = len(Counter(categories))
            elegance = total_profit + distinct_categories ** 2
            max_elegance = max(max_elegance, elegance)
        
        return max_elegance",1
"class Solution {
public:
    long long findMaximumElegance(std::vector<std::vector<int>>& items, int k) {
        std::unordered_map<int, std::vector<int>> categoryToProfits;
        std::unordered_map<int, long long> categoryToTotalProfit;

        for (auto& item : items) {
            int profit = item[0];
            int category = item[1];
            categoryToProfits[category].push_back(profit);
            categoryToTotalProfit[category] += profit;
        }

        std::vector<long long> maxProfits;
        long long totalElegance = 0;

        for (auto& pair : categoryToProfits) {
            int category = pair.first;
            std::vector<int>& profits = pair.second;

            std::sort(profits.rbegin(), profits.rend());

            long long categoryTotalProfit = categoryToTotalProfit[category];
            int categoryDistinctCount = profits.size();

            for (int i = 0; i < k && i < categoryDistinctCount; ++i) {
                totalElegance += profits[i] + static_cast<long long>(categoryDistinctCount) * categoryDistinctCount;
                maxProfits.push_back(profits[i]);
            }
        }

        std::sort(maxProfits.rbegin(), maxProfits.rend());

        for (int i = k; i < maxProfits.size(); ++i) {
            totalElegance -= maxProfits[i];
        }

        return totalElegance;
    }
};",1
"class Solution {
    public int maxSum(int[] nums) {
        int max = 0;
        int maxDigit = 0;
        for(int i = 0; i < nums.length; i++){
            int digit = 0;
            int num = nums[i];
            while(num > 0){
                digit = Math.max(digit, num % 10);
                num /= 10;
            }
            if(digit > maxDigit){
                maxDigit = digit;
                max = nums[i];
            }
            else if(digit == maxDigit){
                max = Math.max(max, nums[i]);
            }
        }
        
        int maxSum = 0;
        for(int i = 0; i < nums.length; i++){
            int digit = 0;
            int num = nums[i];
            while(num > 0){
                digit = Math.max(digit, num % 10);
                num /= 10;
            }
            if(digit == maxDigit){
                maxSum = Math.max(maxSum, nums[i]);
            }
        }
        
        if(maxSum == 0){
            return -1;
        }
        
        int sum = 0;
        for(int i = 0; i < nums.length; i++){
            if(nums[i] == max){
                sum += nums[i];
            }
            else if(nums[i] == maxSum){
                sum += nums[i];
            }
        }
        
        return sum;
    }
}",1
"class Solution:
    def maxSum(self, nums: List[int]) -> int:
        for i in range(len(nums)):
            for j in range(i+1, len(nums)):
                if max(nums[i], nums[j]) % 10 == max(nums[i] // 10, nums[j] // 10):
                    return max(nums[i], nums[j])
        return -1",1
"class Solution {
public:
    int maxSum(vector<int>& nums) {
       int n = nums.size();
        int max_digit = 0;
        for(int i = 0; i < n; i++){
            int digit = 0;
            int num = nums[i];
            while(num){
                digit = max(digit, num % 10);
                num /= 10;
            }
            max_digit = max(max_digit, digit);
        }
        
        int max_sum = -1;
        for(int i = 0; i < n; i++){
            for(int j = i + 1; j < n; j++){
                int digit = 0;
                int num = nums[i] + nums[j];
                while(num){
                    digit = max(digit, num % 10);
                    num /= 10;
                }
                if(digit == max_digit){
                    max_sum = max(max_sum, nums[i] + nums[j]);
                }
            }
        }
        
        return max_sum;
    }
};",1
"class Solution {
    public String finalString(String s) {
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < s.length(); i++){
            if(s.charAt(i) == 'i'){
                sb.reverse();
            }
            else{
                sb.append(s.charAt(i));
            }
        }
        return sb.toString();
    }
}",1
"class Solution:
    def finalString(self, s: str) -> str:
        res = """"
        for i in s:
            if i == ""i"":
                res = res[::-1]
            else:
                res += i
        return res",1
"class Solution {
public:
    string finalString(string s) {
        string ans;
        for(int i = 0; i < s.length(); i++){
            if(s[i] == 'i'){
                reverse(ans.begin(), ans.end());
            }
            else{
                ans.push_back(s[i]);
            }
        }
        return ans;
    }
};",1
"class Solution {
    public int minAbsoluteDifference(List<Integer> nums, int x) {
        int min = Integer.MAX_VALUE;
        int n = nums.size();
        for(int i = 0; i < n; i++){
            for(int j = i + x; j < n; j++){
                min = Math.min(min, Math.abs(nums.get(i) - nums.get(j)));
            }
        }
        return min;
    }
}",1
"class Solution:
    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:
        nums.sort()
        min_diff = float('inf')
        for i in range(len(nums)):
            if i + x < len(nums):
                min_diff = min(min_diff, abs(nums[i] - nums[i + x]))
        return min_diff",1
"class Solution {
public:
    int minAbsoluteDifference(vector<int>& nums, int x) {
        int n=nums.size();
        int min=INT_MAX;
        int i=0;
        int j=0;
        for(i=0;i<n;i++){
            for(j=i+1;j<n;j++){
                if(abs(nums[i]-nums[j])<min && abs(i-j)>=x){
                    min=abs(nums[i]-nums[j]);
                }
            }
        }
        return min;
    }
};",1
"class Solution {
    public ListNode doubleIt(ListNode head) {
        ListNode temp = head;
        ListNode prev = null;
        while(temp!=null){
            int val = temp.val;
            temp.val = val*2;
            if(temp.val>9){
                temp.val = temp.val%10;
                if(prev!=null){
                    prev.val+=1;
                }
            }
            prev = temp;
            temp = temp.next;
        }
        return head;
    }
}",1
"class Solution:
    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head is None:
            return None
        
        head.val = head.val * 2
        
        if head.next is None:
            return head
        
        head.next = self.doubleIt(head.next)
        
        if head.val > 9:
            head.val = head.val - 10
            head.next.val = head.next.val + 1
            
        return head",1
"class Solution {
public:
    ListNode* doubleIt(ListNode* head) {
        ListNode* temp = head;
         ListNode* temp2 = head;
         while(temp->next!=NULL){
             temp2 = temp2->next;
             temp = temp->next;
         }
         temp2->next = head;
         temp = temp2;
         while(temp->next!=NULL){
             temp->val = temp->val*2;
             if(temp->val>9){
                 temp->val = temp->val%10;
                 temp->next->val = temp->next->val+1;
             }
             temp = temp->next;
         }
         if(temp->val>9){
             temp->val = temp->val%10;
             temp->next = new ListNode(1);
         }
         return head;
    }
};",1
"class Solution {
    public int maximumScore(List<Integer> nums, int k) {
        int n = nums.size();
        int[][] dp = new int[n][k + 1];
        for(int i = 0; i < n; i++)
            Arrays.fill(dp[i], -1);
        return dfs(nums, 0, k, dp);
    }
    public int dfs(List<Integer> nums, int i, int k, int[][] dp){
        if(i == nums.size())
            return 1;
        if(k == 0)
            return 0;
        if(dp[i][k] != -1)
            return dp[i][k];
        int ans = 0;
        for(int j = i; j < nums.size(); j++){
            ans = Math.max(ans, nums.get(j) * dfs(nums, j + 1, k - 1, dp));
        }
        return dp[i][k] = ans;
    }
}",1
"class Solution:
    def maximumScore(self, nums: List[int], k: int) -> int:
        def prime_score(num):
            prime_factors = set()
            while num > 1:
                for i in range(2, num + 1):
                    if num % i == 0:
                        prime_factors.add(i)
                        num //= i
                        break
            return len(prime_factors)
        
        n = len(nums)
        dp = [[0] * n for _ in range(k + 1)]
        dp[0][0] = 1
        for i in range(1, k + 1):
            for j in range(1, n):
                for k in range(j):
                    if prime_score(nums[k]) > prime_score(nums[j]):
                        dp[i][j] = max(dp[i][j], dp[i - 1][k] * nums[j])
                    else:
                        dp[i][j] = max(dp[i][j], dp[i][k] * nums[j])
        return dp[k][n - 1] % (10 ** 9 + 7)",1
"class Solution {
public:
    int maximumScore(vector<int>& nums, int k) { 
       int n = nums.size();
        vector<int> primes;
        for(int i = 2; i <= n; i++){
            bool isPrime = true;
            for(int j = 2; j <= sqrt(i); j++){
                if(i % j == 0){
                    isPrime = false;
                    break;
                }
            }
            if(isPrime){
                primes.push_back(i);
            }
        }
        vector<int> dp(n + 1, 0);
        dp[0] = 1;
        for(int i = 1; i <= n; i++){
            for(int j = 0; j < primes.size(); j++){
                if(primes[j] <= nums[i - 1]){
                    dp[i] = (dp[i] + dp[i - 1]) % MOD;
                }
            }
        }
        int ans = 0;
        for(int i = 0; i <= n; i++){
            for(int j = 0; j <= n; j++){
                if(i + j <= n){
                    ans = (ans + dp[i] * dp[n - i - j] % MOD) % MOD;
                }
            }
        }
        return ans;
    }
    
    int MOD = 1e9 + 7;
};",1
"class Solution {
    public long findMaximumElegance(int[][] items, int k) {
        int n = items.length;
        long[][] dp = new long[n + 1][k + 1];
        for (int i = 1; i <= n; i++) {
            int profit = items[i - 1][0];
            int category = items[i - 1][1];
            for (int j = 1; j <= k; j++) {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1] + profit);
                if (category != items[i - 1][1]) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j] + profit);
                }
            }
        }
        long max = 0;
        for (int i = 1; i <= k; i++) {
            max = Math.max(max, dp[n][i]);
        }
        return max;
    }
}",1
"class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        n = len(items)
        profit = [0] * n
        category = [0] * n
        for i in range(n):
            profit[i] = items[i][0]
            category[i] = items[i][1]
        profit.sort(reverse=True)
        category.sort(reverse=True)
        profit = profit[:k]
        category = category[:k]
        
        profit_set = set(profit)
        category_set = set(category)
        
        profit_sum = sum(profit)
        category_sum = sum(category)
        
        return profit_sum + category_sum ** 2",1
"class Solution {
public:
    long long findMaximumElegance(vector<vector<int>>& items, int k) {
        int n = items.size();
        vector<int> profit(n);
        vector<int> category(n);
        
        for(int i = 0; i < n; i++){
            profit[i] = items[i][0];
            category[i] = items[i][1];
        }
        
        sort(profit.begin(), profit.end());
        sort(category.begin(), category.end());
        
        int max_elegance = 0;
        
        for(int i = 0; i < n; i++){
            int j = i + k - 1;
            if(j >= n) break;
            
            int total_profit = profit[j] - profit[i];
            int distinct_categories = upper_bound(category.begin(), category.end(), category[j]) - upper_bound(category.begin(), category.end(), category[i]);
            
            max_elegance = max(max_elegance, total_profit + distinct_categories * distinct_categories);
        }
        
        return max_elegance;
    }
};",1
"public class Solution{
    public int maxSum(int[] nums) {
        int max = -1;
        for(int i = 0; i < nums.length; i++) {
            for(int j = i + 1; j < nums.length;
                    j++) {
                if(nums[i] % 10 == nums[j] % 10) {
                    max = Math.max(max, nums[i] + nums[j]);
                }
            }
            
        }
        return max;
        
    }
    
}",1
"class Solution:
    def maxSum(self, nums: List[int]) -> int:
        nums.sort(reverse=True)
        for i in range(len(nums)-1):
            if nums[i]%10==nums[i+1]%10:
                return nums[i]+nums[i+1]
        return -1",1
"class Solution {
public:
    int maxSum(vector<int>& nums) {
        int ans = -1;
        int n = nums.size();
        for(int i = 0; i < n; i++){
            for(int j = i + 1; j < n; j++){
                if(nums[i] % 10 == nums[j] % 10){
                    ans = max(ans, nums[i] + nums[j]);
                    break;
                }
            }
        }
        return ans;
    }
};",1
"public class Solution {
    public String finalString(String s) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c == 'i') {
                sb.append(s.substring(i));
                break;
            }
            sb.append(c);
        }
        return sb.toString();
        
    }
    
}",1
"class Solution:
    def finalString(self, s: str) -> str:
        ans = """"
        for i in range(len(s)):
            if s[i] == 'i':
                ans = ans[:-1]
            else:
                ans += s[i]
        return ans",1
"class Solution {
public:
    string finalString(string s) {
        string ans="""";
        for(int i=0;i<s.length();i++){
            if(s[i]=='i'){
                reverse(ans.begin(),ans.end());
                ans="""";
                continue;
            }
            ans+=s[i];
        }
        return ans;
    }
};",1
"class Solution {
    public int minAbsoluteDifference(List<Integer> nums, int x) {
        int min = Integer.MAX_VALUE;
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (Math.abs(i - j) >= x) {
                    min = Math.min(min, Math.abs(nums.get(i) - nums.get(j)));
                }
            }
        }
        return min;
        
    }
    
}",1
"class Solution:
    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:
        nums.sort()
        ans = float('inf')
        for i in range(len(nums)):
            j = bisect_left(nums, nums[i] + x)
            if j < len(nums):
                ans = min(ans, nums[j] - nums[i])
            if i + 1 < len(nums):
                ans = min(ans, nums[i + 1] - nums[i])
        return ans",1
"class Solution {
public:
    int minAbsoluteDifference(vector<int>& nums, int x) {
        int n = nums.size();
        int ans = INT_MAX;
        for(int i = 0; i < n; i++){
            for(int j = i + 1; j < n; j++){
                if(abs(nums[i] - nums[j]) >= x){
                    ans = min(ans, abs(nums[i] - nums[j]));
                    break;
                }
            }
        }
        return ans;
    }
};",1
"class Solution {
    public ListNode doubleIt(ListNode head) {
        ListNode curr = head;
        while (curr != null) {
            curr.val *= 2;
            curr = curr.next;
        }
        return head;
        
    }
    
}",1
"class Solution:
    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head:
            return head
        if not head.next:
            head.val *= 2
            return head
        prev = head
        curr = head.next
        while curr:
            curr.val *= 2
            prev = curr
            curr = curr.next
        prev.val *= 2
        return head",1
"class Solution {
public:
    ListNode* doubleIt(ListNode* head) {
        if(head == NULL)
            return NULL;
        ListNode* temp = head;
        while(temp->next != NULL){
            temp->val *= 2;
            temp = temp->next;
            if(temp->next != NULL) {
                temp->val *= 2;
                temp = temp->next;
                continue;
            }
            else {
                break;
            }
        }
        return head;
    }
};",1
"public class Solution {
    public int maximumScore(List<Integer> nums, int k) {
        int n = nums.size();
        int[] primes = new int[n];
        for (int i = 0; i < n; i++) {
            primes[i] = primeFactors(nums.get(i));
            if (primes[i] == 0) primes[i] = 1;
            //System.out.println(primes[i]);
        }
        int[][] dp = new int[n][k + 1];
        for (int i = 0; i < n; i++) {
            dp[i][0] = 1;
        }
        for (int i = 1; i <= k; i++) {
            for (int j = 0; j < n; j++) {
                dp[j][i] = Math.max(dp[j][i - 1], dp[j - 1][i - 1] * primes[j]);
            }
        }
        return dp[n - 1][k];
        
    }
    
    public int primeFactors(int n) {
        int count = 0;
        for (int i = 2; i <= n / i; i++) {
            while (n % i == 0) {
                n /= i;
                count++;
            }
        }
        if (n > 1) count++;
        return count;
    }
    
}",1
"class Solution:
    def maximumScore(self, nums: List[int], k: int) -> int:
        def prime(n):
            if n == 1:
                return False
            for i in range(2, int(n**0.5)+1):
                if n % i == 0:
                    return False
            return True
        ans = 1
        for i in range(k, -1, -1):
            if prime(nums[i]):
                ans *= nums[i]
        for i in range(k+1, len(nums)):
            if prime(nums[i]):
                ans *= nums[i]
        return ans % (10**9 + 7)",1
"class Solution {
public:
    int maximumScore(vector<int>& nums, int k) {
        int n = nums.size();
        int l = k, r = k;
        int score = 1;
        int ans = 0;
        while(l >= 0 || r < n){
            if(l < 0){
                score *= nums[r++];
                ans = max(ans, score);
                continue;
            }
            if(r == n){
                score *= nums[l--];
                ans = max(ans, score);
                continue;
            }
            if(nums[l] < nums[r]){
                score *= nums[l--];
                ans = max(ans, score);
            }
            else{
                score *= nums[r++];
                ans = max(ans, score);
            }
        }
        return ans;
    }
};",1
"public class Solution {
    public int findMaximumElegance(int[][] items, int k) {
        int n = items.length;
        int[] category = new int[n];
        for (int i = 0; i < n; i++) {
            category[i] = items[i][1];
        }
        int[] count = new int[n + 1];
        for (int i = 0; i < n; i++) {
            count[category[i]]++;
        }
        for (int i = 1; i <= n; i++) {
            count[i] += count[i - 1];
        }
        int[] dp = new int[n + 1];
        for (int i = 0; i < n; i++) {
            int index = count[category[i]];
            dp[index] = Math.max(dp[index], dp[index - 1] + items[i][0]);
        }
        return dp[n];
        
    }

}",1
"class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        items.sort(key = lambda x: x[1])
        ans = 0
        for i in range(k):
            ans += items[i][0]
        return ans + (k * (k - 1) // 2) * items[k - 1][1]",1
"class Solution {
public:
    long long findMaximumElegance(vector<vector<int>>& items, int k) {
        int n=items.size();
        vector<long long>profit(n);
        vector<long long>category(n);
        for(int i=0;i<n;i++){
            profit[i]=items[i][0];
            category[i]=items[i][1];
        }
        sort(profit.begin(),profit.end());
        sort(category.begin(),category.end());
        long long ans=0;
        long long max_profit=0;
        long long max_category=0;
        for(int i=0;i<n;i++){
            if(i<k){
                max_profit+=profit[i];
                max_category+=category[i];
                ans=max(ans,max_profit+max_category*max_category);
                continue;
            }
            max_profit-=profit[i-k];
            max_profit+=profit[i];
            max_category-=category[i-k];
            max_category+=category[i];
            ans=max(ans,max_profit+max_category*max_category);
        }
        return ans;
    }
};",1
"public class Solution {
    public int maxSum(int[] nums) {
        int max = -1;
        for(int i = 0; i < nums.length; i++){
            for(int j = i+1; j < nums.length;j++){
                if(max < nums[i] + nums[j] && maxDigit(nums[i]) == maxDigit(nums[j])){
                    max = nums[i] + nums[j];
                }
            }
        }
        return max;
    }
    public int maxDigit(int num){
        int max = 0;
        while(num > 0){
            max = Math.max(max, num % 10);
            num /= 10;
        }
        return max;
    }
}",1
"class Solution:
    def maxSum(self, nums: List[int]) -> int:
        maxSum = -1
        maxDigit = [0] * 10
        for num in nums:
            maxDigit[int(str(num)[0])] = max(maxDigit[int(str(num)[0])], num)
        for i in range(10):
            
            for j in range(i, 10):
                if maxDigit[i] and maxDigit[j]:
                    maxSum = max(maxSum, maxDigit[i] + maxDigit[j])
        return maxSum",1
"class Solution {
public:
    int maxSum(vector<int>& nums) {
        int n = nums.size();
        int maxSum = -1;
        unordered_map<int, int> mp;
        for(int i = 0; i < n; i++) {
            int maxDigit = 0;
            int temp = nums[i];
            while(temp) {
                maxDigit = max(maxDigit, temp % 10);
                temp /= 10;
            }
            if(mp.find(maxDigit) != mp.end()) {
                maxSum = max(maxSum, mp[maxDigit] + nums[i]);
                mp[maxDigit] = max(mp[maxDigit], nums[i]);
            } else {
                mp[maxDigit] = nums[i];
            }
        }
        return maxSum;
    }
};",1
"public class Solution {
    public String finalString(String s) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == 'i') {
                sb.reverse();
            } else {
                sb.append(s.charAt(i));
            }
        }
        return sb.toString();
    }
}",1
"class Solution:
    def finalString(self, s: str) -> str:
        stack = []
        for i in range(len(s)):
            if s[i] == 'i':
                stack.reverse()
            else:
                stack.append(s[i])
        return """".join(stack)",1
"class Solution {
public:
    string finalString(string s) {
        string ans = """";
        int n = s.length();
        int i = 0;
        while(i < n) {
            if(s[i] == 'i') {
                reverse(ans.begin(), ans.end());
            } else {
                ans += s[i];
            }
            i++;
        }
        return ans;
    }
};",1
"class Solution {
    public int minAbsoluteDifference(List<Integer> nums, int x) {
        int min = Integer.MAX_VALUE;
        int n = nums.size();
        for(int i = 0; i < n; i++){
            for(int j = i + x; j < n; j++){
                min = Math.min(min, Math.abs(nums.get(i) - nums.get(j)));
            }
        }
        return min;
    }
}",1
"class Solution:
    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:
        nums.sort()
        n = len(nums)
        res = float('inf')
        for i in range(n):
            j = bisect_left(nums, nums[i] - x, i + 1)
            if j < n:
                res = min(res, abs(nums[i] - nums[j] + x))
            if j > i + 1:
                res = min(res, abs(nums[i] - nums[j - 1] + x))
        return res",1
"class Solution {
public:
    int minAbsoluteDifference(vector<int>& nums, int x) {
        int n = nums.size();
        int ans = INT_MAX;
        for(int i = 0; i < n; i++){
            for(int j = i + x; j < n; j++){
                ans = min(ans, abs(nums[i] - nums[j]));
            }
        }
        return ans;
    }
};",1
"class Solution {
    public ListNode doubleIt(ListNode head) {
        ListNode curr = head;
        ListNode prev = null;
        while(curr != null) {
            ListNode next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }
        
        ListNode newHead = prev;
        ListNode newCurr = newHead;
        ListNode carry = null;
        while(newCurr != null) {
            int sum = newCurr.val * 2;
            if(carry != null) {
                sum += carry.val;
                carry = null;
            }
            if(sum > 9) {
                carry = new ListNode(sum / 10);
                sum = sum % 10;
            }
            newCurr.val = sum;
            newCurr = newCurr.next;
        }
        if(carry != null) {
            newCurr = newHead;
            while(newCurr.next != null) {
                newCurr = newCurr.next;
            }
            newCurr.next = carry;
        }
        return reverse(newHead);
    }
    
    public ListNode reverse(ListNode head) {
        ListNode curr = head;
        ListNode prev = null;
        while(curr != null) {
            ListNode next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }
        
        return prev;
    }
}",1
"class Solution:
    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head is None:
            return None
        if head.next is None:
            head.val = head.val * 2
            return head
        node = head
        while node:
            node.val = node.val * 2
            node = node.next
        node = head
        while node:
            if node.val > 9:
                node.val = node.val % 10
                if node.next is None:
                    node.next = ListNode(1)
                else:
                    node.next.val += 1
            node = node.next
        return head",1
"class Solution {
public:
    ListNode* doubleIt(ListNode* head) {
        ListNode* temp = head;
        ListNode* prev = NULL;
        while(temp != NULL) {
            temp->val *= 2;
            if(temp->val > 9) {
                if(prev == NULL) {
                    ListNode* newHead = new ListNode(1);
                    newHead->next = head;
                    head = newHead;
                    temp->val -= 10;
                } else {
                    prev->val += 1;
                    temp->val -= 10;
                }
            }
            prev = temp;
            temp = temp->next;
        }
        return head;
    }
};",1
"public class Solution {
    public int maximumScore(List<Integer> nums, int k) {
        int n = nums.size();
        int[] left = new int[n];
        int[] right = new int[n];
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < n; i++) {
            while (!stack.isEmpty() && nums.get(stack.peek()) >= nums.get(i)) {
                stack.pop();
            }
            left[i] = stack.isEmpty() ? -1 : stack.peek();
            stack.push(i);
        }
        stack.clear();
        for (int i = n - 1; i >= 0; i--) {
            while (!stack.isEmpty() && nums.get(stack.peek()) >= nums.get(i)) {
                stack.pop();
            }
            right[i] = stack.isEmpty() ? n : stack.peek();
            stack.push(i);
        }
        int ans = 0;
        for (int i = 0; i < n; i++) {
            if (left[i] < k && right[i] > k) {
                ans = Math.max(ans, nums.get(i) * (right[i] - left[i] - 1));
            }
        }
        return ans;
    }
}",1
"class Solution:
    def maximumScore(self, nums: List[int], k: int) -> int:
        n = len(nums)
        left, right = k, k
        res = nums[k]
        min_val = nums[k]
        while left > 0 or right < n - 1:
            if left == 0:
                right += 1
            elif right == n - 1:
                left -= 1
            elif nums[left - 1] < nums[right + 1]:
                right += 1
            else:
                left -= 1
            min_val = min(min_val, nums[left], nums[right])
            res = max(res, min_val * (right - left + 1))
        return res",1
"class Solution {
public:
    int maximumScore(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> left(n, -1), right(n, n);
        stack<int> st;
        for(int i = 0; i < n; i++) {
            while(!st.empty() && nums[st.top()] >= nums[i]) {
                st.pop();
            }
            if(!st.empty()) {
                left[i] = st.top();
            }
            st.push(i);
        }
        while(!st.empty()) {
            st.pop();
        }
        for(int i = n - 1; i >= 0; i--) {
            while(!st.empty() && nums[st.top()] >= nums[i]) {
                st.pop();
            }
            if(!st.empty()) {
                right[i] = st.top();
            }
            st.push(i);
        }
        vector<int> primes(100001, 0);
        for(int i = 2; i <= 100000; i++) {
            if(primes[i] == 0) {
                for(int j = i; j <= 100000; j += i) {
                    primes[j]++;
                }
            }
        }
        vector<int> dp(n, 0);
        for(int i = 0; i < n; i++) {
            dp[i] = nums[i] * (primes[nums[i]] + 1);
        }
        for(int i = 1; i < n; i++) {
            dp[i] = max(dp[i], dp[i - 1]);
        }
        int ans = 0;
        for(int i = 0; i < n; i++) {
            int l = left[i] + 1, r = right[i] - 1;
            if(l <= k && k <= r) {
                ans = max(ans, nums[i] * dp[r]);
            }
            if(l <= k - 1 && k - 1 <= r) {
                ans = max(ans, nums[i] * dp[r]);
            }
            if(l <= k && k <= r + 1) {
                ans = max(ans, nums[i] * dp[r]);
            }
            if(l <= k - 1 && k - 1 <= r + 1) {
                ans = max(ans, nums[i] * dp[r]);
            }
        }
        return ans;
    }
};",1
"public class Solution {
    public int findMaximumElegance(int[][] items, int k) {
        int n = items.length;
        int[] dp = new int[n];
        Arrays.sort(items, (a, b) -> a[0] - b[0]);
        int max = 0;
        for (int i = 0; i < n; i++) {
            int profit = items[i][0];
            int category = items[i][1];
            dp[i] = profit + category * category;
            for (int j = 0; j < i; j++) {
                if (items[j][1] != category) {
                    dp[i] = Math.max(dp[i], dp[j] + profit + category * category);
                }
            }
            if (i >= k - 1) {
                max = Math.max(max, dp[i]);
            }
        }
        return max;
    }
}",1
"class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        items.sort(key = lambda x: x[0], reverse = True)
        category = {}
        for i in range(len(items)):
            if items[i][1] not in category:
                category[items[i][1]] = 1
            else:
                category[items[i][1]] += 1
        category = sorted(category.items(), key = lambda x: x[1], reverse = True)
        ans = 0
        for i in range(k):
            ans += items[i][0]
        ans += len(category) ** 2
        return ans",1
"class Solution {
public:
    long long findMaximumElegance(vector<vector<int>>& items, int k) {
        int n = items.size();
        vector<pair<int,int>> v;
        for(int i=0;i<n;i++){
            v.push_back({items[i][0],items[i][1]});
        }
        sort(v.begin(),v.end(),greater<pair<int,int>>());
        int i=0;
        long long ans = 0;
        unordered_map<int,int> mp;
        while(i<n && k>0){
            if(mp[v[i].second]==0){
                ans += v[i].first;
                mp[v[i].second]++;
                k--;
            }
            i++;
        }
        return ans + (k*k);
    }
};",1
"class Solution {
    public int maxSum(int[] nums) {
    int ans = -1;
    Map<Integer,List<Integer>> ump = new HashMap<>();
    for(int i = 0; i < nums.length; ++i){
        int t = nums[i], maxDigit = 0;
        while(t != 0){ //evaluate max digit in the number
            maxDigit = Math.max(t%10, maxDigit);
            t = t/10;
        }
        if(!ump.containsKey(maxDigit)) ump.put(maxDigit, new ArrayList<>());
        ump.get(maxDigit).add(nums[i]); // add the number to the map 
    }
    for(Map.Entry<Integer, List<Integer>> entry: ump.entrySet()){
        entry.getValue().sort(Comparator.reverseOrder()); //to find max two number in each max digit 
        if(entry.getValue().size() >= 2) ans = Math.max(ans, entry.getValue().get(0) + entry.getValue().get(1)); //sum max two number and take max
    }
    return ans;
    }
}",0
"class Solution:
    def maxSum(self, nums: List[int]) -> int:
        max_by_digit = defaultdict(int)
        max_sum = -1

        for num in nums:
            digit = max(str(num))

            if digit in max_by_digit:
                max_sum = max(max_sum, max_by_digit[digit] + num)

            max_by_digit[digit] = max(max_by_digit[digit], num)

        return max_sum",0
"class Solution {
    public:
        int maxSum(vector<int>& nums) {
        int res = -1, max_num[10] = {};
        for (auto num : nums) {
            int max_d = 0;
            for (int v = num; v; v /= 10)
                max_d = max(max_d, v % 10);
            if (max_num[max_d])
                res = max(res, max_num[max_d] + num);
            max_num[max_d] = max(max_num[max_d], num);
        }
        return res;
    }
};",0
"class Solution {
    public String finalString(String s) {
        StringBuilder nm=new StringBuilder();
        for(char c:s.toCharArray())
        {
            if(c=='i')
            {
                nm.reverse();
            }
            else
            {
                nm.append(c);
            }
        }
        return nm.toString();
    }
}",0
"class Solution:
    def finalString(self, s: str) -> str:
        while ""i"" in s:
            index=s.index(""i"")

            #first half and second half
            first=s[:index][::-1]
            second=s[index+1:]

            s="""".join([first,second])
        return s",0
"class Solution {
public:
    string finalString(const string &s) {
        string a, b;
        for (char ch : s)
            if (ch == 'i')
                swap(a, b);
            else
                a += ch;
        return string(rbegin(b), rend(b)) + a;
    }
};",0
"class Solution {
    int minAbsoluteDifference(List<Integer> nums, int x) {
        int ans = Integer.MAX_VALUE;
        TreeSet<Integer> s = new TreeSet<>();
        for(int i = x; i < nums.size(); ++i){
            s.add(nums.get(i-x));
            Integer high = s.ceiling(nums.get(i)), low = s.floor(nums.get(i));
            if(high != null) ans = Math.min(ans, Math.abs(nums.get(i) - high));
            if(low != null) ans = Math.min(ans, Math.abs(nums.get(i) - low));
        }
        return ans;
    }
}",0
"class Solution:
  def minAbsoluteDifference(self, nums: List[int], x: int) -> int:
    if x == 0:
      return 0

    arr, best_dist = SortedList([]), float('inf')
    for i in range(x, len(nums)):
      arr.add(nums[i - x])
      v = nums[i]

      pos = arr.bisect_left(v)
      if pos < len(arr):
        best_dist = min(best_dist, abs(arr[pos] - v))
      if pos > 0:
        best_dist = min(best_dist, abs(arr[pos - 1] - v))
    
    return best_dist",0
"class Solution {
public:
    int minAbsoluteDifference(vector<int>& nums, int x) {
        int ans = INT_MAX;
        set<int> s;
        for(int i = x; i < nums.size(); ++i){
            s.insert(nums[i-x]);
            auto it = s.upper_bound(nums[i]);
            if(it != s.end()) ans = min(ans, abs(nums[i] - *it));
            if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));
        }
        return ans;
    }
};",0
"class Solution {
    public ListNode doubleIt(ListNode head) {
        if (head.val > 4)
            head = new ListNode(0, head);
        for(ListNode node = head; node != null; node = node.next) {
            node.val = (node.val * 2) % 10;
            if (node.next != null && node.next.val > 4)
                node.val++;
        }
        return head;
    }
}",0
"class Solution:
    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head.val > 4:
            head = ListNode(0, head)
        node = head
        while node:
            node.val = (node.val * 2) % 10
            if node.next and node.next.val > 4:
                node.val += 1
            node = node.next
        return head",0
"class Solution {
public:
    ListNode* doubleIt(ListNode* head) {
        if (head->val > 4)
            head = new ListNode(0, head);
        for(ListNode* node = head; node; node = node->next) {
            node->val = (node->val * 2) % 10;
            if (node->next && node->next->val > 4)
                node->val++;
        }
        return head;
    }
};",0
"class Solution {
    static final int MOD = 1000000007;

    public int maximumScore(List<Integer> nums, int k) {
        int n = nums.size();

        int upper = Collections.max(nums) + 1;

        boolean[] prime = new boolean[upper];
        int[] primeScore = new int[upper];
        Arrays.fill(prime, true);
        prime[0] = prime[1] = false;
        for (int i = 2; i < upper; i++) {
            if (prime[i]) {
                for (int j = i; j < upper; j += i) {
                    primeScore[j]++;
                    prime[j] = false;
                }
            }
        }

        int[] nextGreaterElement = new int[n];
        Arrays.fill(nextGreaterElement, n);
        Stack<Integer> s = new Stack<>();
        for (int i = n - 1; i >= 0; i--) {
            while (!s.empty() && primeScore[nums.get(i)] >= primeScore[nums.get(s.peek())]) {
                s.pop();
            }
            nextGreaterElement[i] = s.empty() ? n : s.peek();
            s.push(i);
        }

        int[] prevGreaterOrEqualElement = new int[n];
        Arrays.fill(prevGreaterOrEqualElement, -1);
        s = new Stack<>();
        for (int i = 0; i < n; i++) {
            while (!s.empty() && primeScore[nums.get(i)] > primeScore[nums.get(s.peek())]) {
                s.pop();
            }
            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.peek();
            s.push(i);
        }

        int res = 1;
        int[][] tuples = new int[n][2];
        for (int i = 0; i < n; i++) {
            tuples[i][0] = nums.get(i);
            tuples[i][1] = i;
        }
        Arrays.sort(tuples, new Comparator<int[]>() {
            public int compare(int[] a, int[] b) {
                return b[0] - a[0];
            }
        });
        for (int i = 0; i < n; i++) {
            int num = tuples[i][0];
            int idx = tuples[i][1];
            int operations = Math.min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k);
            res = (int)((1L * res * pow(num, operations)) % MOD);
            k -= operations;
            if (k == 0) {
                return res;
            }
        }

        return res;
    }

    public int pow(int x, int n) {
        int res = 1;
        while (n > 0) {
            if (n % 2 == 1) {
                res = (int)((1L * res * x) % MOD);
            }
            x = (int)((1L * x * x) % MOD);
            n /= 2;
        }
        return res;
    }
}",0
"class Solution: 
    MOD = 1000000007

    def maximumScore(self, nums: List[int], k: int) -> int:
        n = len(nums)

        upper = max(nums) + 1

        prime = [True]*upper
        prime[0] = prime[1] = False
        primeScore = [0]*upper
        for i in range(2, upper):
            if prime[i]:
                for j in range(i, upper, i):
                    primeScore[j] += 1
                    prime[j] = False

        nextGreaterElement = [n]*n
        s = []
        for i in range(n - 1, -1, -1):
            while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:
                s.pop()
            nextGreaterElement[i] = s[-1] if s else n
            s.append(i)

        prevGreaterOrEqualElement = [-1]*n
        s = []
        for i in range(n):
            while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:
                s.pop()
            prevGreaterOrEqualElement[i] = s[-1] if s else -1
            s.append(i)

        res = 1
        tuples = [[nums[i], i] for i in range(n)]
        tuples.sort(reverse=True)
        for num, idx in tuples:
            operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)
            res = (res * self.pow(num, operations)) % self.MOD
            k -= operations
            if k == 0:
                return res

        return res

    def pow(self, x: int, n: int) -> int:
        res = 1
        while n > 0:
            if n % 2 == 1:
                res = (res * x) % self.MOD
            x = (x * x) % self.MOD
            n //= 2
        return res",0
"class Solution {
public:
    const int MOD = 1000000007;

    int maximumScore(vector<int>& nums, int k) {
        int n = nums.size();

        int upper = *max_element(nums.begin(), nums.end()) + 1;

        vector<bool> prime(upper, true);
        prime[0] = prime[1] = false;
        vector<int> primeScore(upper, 0);
        for (int i = 2; i < upper; i++) {
            if (prime[i]) {
                for (int j = i; j < upper; j += i) {
                    primeScore[j]++;
                    prime[j] = false;
                }
            }
        }

        vector<int> nextGreaterElement(n, n);
        stack<int> s;
        for (int i = n - 1; i >= 0; i--) {
            while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {
                s.pop();
            }
            nextGreaterElement[i] = s.empty() ? n : s.top();
            s.push(i);
        }

        vector<int> prevGreaterOrEqualElement(n, -1);
        s = stack<int>();
        for (int i = 0; i < n; i++) {
            while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {
                s.pop();
            }
            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();
            s.push(i);
        }

        int res = 1;
        vector<pair<int, int>> tuples(n);
        for (int i = 0; i < n; i++) {
            tuples[i].first = nums[i];
            tuples[i].second = i;
        }
        sort(tuples.rbegin(), tuples.rend());
        for (const auto& [num, i] : tuples) {
            int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);
            res = (int)((1L * res * pow(num, operations)) % MOD);
            k -= operations;
            if (k == 0) {
                return res;
            }
        }

        return res;
    }

    int pow(int x, int n) {
        int res = 1;
        while (n > 0) {
            if (n % 2 == 1) {
                res = (int)((1L * res * x) % MOD);
            }
            x = (int)((1L * x * x) % MOD);
            n /= 2;
        }
        return res;
    }
};",0
"class Solution {
    public long findMaximumElegance(int[][] A, int k) {
        Arrays.sort(A, (a, b) -> b[0] - a[0]);
        long res = 0, cur = 0;
        List<Integer> dup = new ArrayList<>();
        Set<Integer> seen = new HashSet<>();
        for (int i = 0; i < A.length; ++i) {
            if (i < k) {
                if (seen.contains(A[i][1])) {
                    dup.add(A[i][0]);
                }
                cur += A[i][0];
            } else if (!seen.contains(A[i][1])) {
                if (dup.isEmpty()) break;
                cur += A[i][0] - dup.remove(dup.size() - 1);
            }
            seen.add(A[i][1]);
            res = Math.max(res, cur + 1L * seen.size() * seen.size());
        }
        return res;
    }
}",0
"class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        items = sorted(items, key=lambda v: -v[0])
        res = cur = 0
        A = []
        seen = set()
        for i, (p, c) in enumerate(items):
            if i < k:
                if c in seen:
                    A.append(p)
                cur += p
            elif c not in seen:
                if not A: break
                cur += p - A.pop()
            seen.add(c)
            res = max(res, cur + len(seen) * len(seen))
        return res",0
"class Solution {
public:
    long long findMaximumElegance(vector<vector<int>>& A, int k) {
        sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {
            return a[0] > b[0];
        });
        long long res = 0, cur = 0;
        vector<int> dup;
        unordered_set<int> seen;
        for (int i = 0; i < A.size(); ++i) {
            if (i < k) {
                if (seen.count(A[i][1])) {
                    dup.push_back(A[i][0]);
                }
                cur += A[i][0];
            } else if (seen.find(A[i][1]) == seen.end()) {
                if (dup.empty()) break;
                cur += A[i][0] - dup.back();
                dup.pop_back();
            }
            seen.insert(A[i][1]);
            res = fmax(res, cur + 1L * seen.size() * seen.size());
        }
        return res;
    }
};",0
"class Solution {
    public int maxSum(int[] nums) {
    int ans = -1;
    Map<Integer,List<Integer>> ump = new HashMap<>();
    for(int i = 0; i < nums.length; ++i){
        int t = nums[i], maxDigit = 0;
        while(t != 0){ //evaluate max digit in the number
            maxDigit = Math.max(t%10, maxDigit);
            t = t/10;
        }
        if(!ump.containsKey(maxDigit)) ump.put(maxDigit, new ArrayList<>());
        ump.get(maxDigit).add(nums[i]); // add the number to the map 
    }
    for(Map.Entry<Integer, List<Integer>> entry: ump.entrySet()){
        entry.getValue().sort(Comparator.reverseOrder()); //to find max two number in each max digit 
        if(entry.getValue().size() >= 2) ans = Math.max(ans, entry.getValue().get(0) + entry.getValue().get(1)); //sum max two number and take max
    }
    return ans;
    }
}",0
"class Solution:
    def maxSum(self, nums: List[int]) -> int:
        max_by_digit = defaultdict(int)
        max_sum = -1

        for num in nums:
            digit = max(str(num))

            if digit in max_by_digit:
                max_sum = max(max_sum, max_by_digit[digit] + num)

            max_by_digit[digit] = max(max_by_digit[digit], num)

        return max_sum",0
"class Solution {
    public:
        int maxSum(vector<int>& nums) {
        int res = -1, max_num[10] = {};
        for (auto num : nums) {
            int max_d = 0;
            for (int v = num; v; v /= 10)
                max_d = max(max_d, v % 10);
            if (max_num[max_d])
                res = max(res, max_num[max_d] + num);
            max_num[max_d] = max(max_num[max_d], num);
        }
        return res;
    }
};",0
"class Solution {
    public String finalString(String s) {
        StringBuilder nm=new StringBuilder();
        for(char c:s.toCharArray())
        {
            if(c=='i')
            {
                nm.reverse();
            }
            else
            {
                nm.append(c);
            }
        }
        return nm.toString();
    }
}",0
"class Solution:
    def finalString(self, s: str) -> str:
        while ""i"" in s:
            index=s.index(""i"")

            #first half and second half
            first=s[:index][::-1]
            second=s[index+1:]

            s="""".join([first,second])
        return s",0
"class Solution {
public:
    string finalString(const string &s) {
        string a, b;
        for (char ch : s)
            if (ch == 'i')
                swap(a, b);
            else
                a += ch;
        return string(rbegin(b), rend(b)) + a;
    }
};",0
"class Solution {
    int minAbsoluteDifference(List<Integer> nums, int x) {
        int ans = Integer.MAX_VALUE;
        TreeSet<Integer> s = new TreeSet<>();
        for(int i = x; i < nums.size(); ++i){
            s.add(nums.get(i-x));
            Integer high = s.ceiling(nums.get(i)), low = s.floor(nums.get(i));
            if(high != null) ans = Math.min(ans, Math.abs(nums.get(i) - high));
            if(low != null) ans = Math.min(ans, Math.abs(nums.get(i) - low));
        }
        return ans;
    }
}",0
"class Solution:
  def minAbsoluteDifference(self, nums: List[int], x: int) -> int:
    if x == 0:
      return 0

    arr, best_dist = SortedList([]), float('inf')
    for i in range(x, len(nums)):
      arr.add(nums[i - x])
      v = nums[i]

      pos = arr.bisect_left(v)
      if pos < len(arr):
        best_dist = min(best_dist, abs(arr[pos] - v))
      if pos > 0:
        best_dist = min(best_dist, abs(arr[pos - 1] - v))
    
    return best_dist",0
"class Solution {
public:
    int minAbsoluteDifference(vector<int>& nums, int x) {
        int ans = INT_MAX;
        set<int> s;
        for(int i = x; i < nums.size(); ++i){
            s.insert(nums[i-x]);
            auto it = s.upper_bound(nums[i]);
            if(it != s.end()) ans = min(ans, abs(nums[i] - *it));
            if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));
        }
        return ans;
    }
};",0
"class Solution {
    public ListNode doubleIt(ListNode head) {
        if (head.val > 4)
            head = new ListNode(0, head);
        for(ListNode node = head; node != null; node = node.next) {
            node.val = (node.val * 2) % 10;
            if (node.next != null && node.next.val > 4)
                node.val++;
        }
        return head;
    }
}",0
"class Solution {
    static final int MOD = 1000000007;

    public int maximumScore(List<Integer> nums, int k) {
        int n = nums.size();

        int upper = Collections.max(nums) + 1;

        boolean[] prime = new boolean[upper];
        int[] primeScore = new int[upper];
        Arrays.fill(prime, true);
        prime[0] = prime[1] = false;
        for (int i = 2; i < upper; i++) {
            if (prime[i]) {
                for (int j = i; j < upper; j += i) {
                    primeScore[j]++;
                    prime[j] = false;
                }
            }
        }

        int[] nextGreaterElement = new int[n];
        Arrays.fill(nextGreaterElement, n);
        Stack<Integer> s = new Stack<>();
        for (int i = n - 1; i >= 0; i--) {
            while (!s.empty() && primeScore[nums.get(i)] >= primeScore[nums.get(s.peek())]) {
                s.pop();
            }
            nextGreaterElement[i] = s.empty() ? n : s.peek();
            s.push(i);
        }

        int[] prevGreaterOrEqualElement = new int[n];
        Arrays.fill(prevGreaterOrEqualElement, -1);
        s = new Stack<>();
        for (int i = 0; i < n; i++) {
            while (!s.empty() && primeScore[nums.get(i)] > primeScore[nums.get(s.peek())]) {
                s.pop();
            }
            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.peek();
            s.push(i);
        }

        int res = 1;
        int[][] tuples = new int[n][2];
        for (int i = 0; i < n; i++) {
            tuples[i][0] = nums.get(i);
            tuples[i][1] = i;
        }
        Arrays.sort(tuples, new Comparator<int[]>() {
            public int compare(int[] a, int[] b) {
                return b[0] - a[0];
            }
        });
        for (int i = 0; i < n; i++) {
            int num = tuples[i][0];
            int idx = tuples[i][1];
            int operations = Math.min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k);
            res = (int)((1L * res * pow(num, operations)) % MOD);
            k -= operations;
            if (k == 0) {
                return res;
            }
        }

        return res;
    }

    public int pow(int x, int n) {
        int res = 1;
        while (n > 0) {
            if (n % 2 == 1) {
                res = (int)((1L * res * x) % MOD);
            }
            x = (int)((1L * x * x) % MOD);
            n /= 2;
        }
        return res;
    }
}",0
"class Solution: 
    MOD = 1000000007

    def maximumScore(self, nums: List[int], k: int) -> int:
        n = len(nums)

        upper = max(nums) + 1

        prime = [True]*upper
        prime[0] = prime[1] = False
        primeScore = [0]*upper
        for i in range(2, upper):
            if prime[i]:
                for j in range(i, upper, i):
                    primeScore[j] += 1
                    prime[j] = False

        nextGreaterElement = [n]*n
        s = []
        for i in range(n - 1, -1, -1):
            while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:
                s.pop()
            nextGreaterElement[i] = s[-1] if s else n
            s.append(i)

        prevGreaterOrEqualElement = [-1]*n
        s = []
        for i in range(n):
            while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:
                s.pop()
            prevGreaterOrEqualElement[i] = s[-1] if s else -1
            s.append(i)

        res = 1
        tuples = [[nums[i], i] for i in range(n)]
        tuples.sort(reverse=True)
        for num, idx in tuples:
            operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)
            res = (res * self.pow(num, operations)) % self.MOD
            k -= operations
            if k == 0:
                return res

        return res

    def pow(self, x: int, n: int) -> int:
        res = 1
        while n > 0:
            if n % 2 == 1:
                res = (res * x) % self.MOD
            x = (x * x) % self.MOD
            n //= 2
        return res",0
"class Solution {
public:
    const int MOD = 1000000007;

    int maximumScore(vector<int>& nums, int k) {
        int n = nums.size();

        int upper = *max_element(nums.begin(), nums.end()) + 1;

        vector<bool> prime(upper, true);
        prime[0] = prime[1] = false;
        vector<int> primeScore(upper, 0);
        for (int i = 2; i < upper; i++) {
            if (prime[i]) {
                for (int j = i; j < upper; j += i) {
                    primeScore[j]++;
                    prime[j] = false;
                }
            }
        }

        vector<int> nextGreaterElement(n, n);
        stack<int> s;
        for (int i = n - 1; i >= 0; i--) {
            while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {
                s.pop();
            }
            nextGreaterElement[i] = s.empty() ? n : s.top();
            s.push(i);
        }

        vector<int> prevGreaterOrEqualElement(n, -1);
        s = stack<int>();
        for (int i = 0; i < n; i++) {
            while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {
                s.pop();
            }
            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();
            s.push(i);
        }

        int res = 1;
        vector<pair<int, int>> tuples(n);
        for (int i = 0; i < n; i++) {
            tuples[i].first = nums[i];
            tuples[i].second = i;
        }
        sort(tuples.rbegin(), tuples.rend());
        for (const auto& [num, i] : tuples) {
            int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);
            res = (int)((1L * res * pow(num, operations)) % MOD);
            k -= operations;
            if (k == 0) {
                return res;
            }
        }

        return res;
    }

    int pow(int x, int n) {
        int res = 1;
        while (n > 0) {
            if (n % 2 == 1) {
                res = (int)((1L * res * x) % MOD);
            }
            x = (int)((1L * x * x) % MOD);
            n /= 2;
        }
        return res;
    }
};",0
"class Solution {
    public long findMaximumElegance(int[][] A, int k) {
        Arrays.sort(A, (a, b) -> b[0] - a[0]);
        long res = 0, cur = 0;
        List<Integer> dup = new ArrayList<>();
        Set<Integer> seen = new HashSet<>();
        for (int i = 0; i < A.length; ++i) {
            if (i < k) {
                if (seen.contains(A[i][1])) {
                    dup.add(A[i][0]);
                }
                cur += A[i][0];
            } else if (!seen.contains(A[i][1])) {
                if (dup.isEmpty()) break;
                cur += A[i][0] - dup.remove(dup.size() - 1);
            }
            seen.add(A[i][1]);
            res = Math.max(res, cur + 1L * seen.size() * seen.size());
        }
        return res;
    }
}",0
"class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        items = sorted(items, key=lambda v: -v[0])
        res = cur = 0
        A = []
        seen = set()
        for i, (p, c) in enumerate(items):
            if i < k:
                if c in seen:
                    A.append(p)
                cur += p
            elif c not in seen:
                if not A: break
                cur += p - A.pop()
            seen.add(c)
            res = max(res, cur + len(seen) * len(seen))
        return res",0
"class Solution {
public:
    long long findMaximumElegance(vector<vector<int>>& A, int k) {
        sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {
            return a[0] > b[0];
        });
        long long res = 0, cur = 0;
        vector<int> dup;
        unordered_set<int> seen;
        for (int i = 0; i < A.size(); ++i) {
            if (i < k) {
                if (seen.count(A[i][1])) {
                    dup.push_back(A[i][0]);
                }
                cur += A[i][0];
            } else if (seen.find(A[i][1]) == seen.end()) {
                if (dup.empty()) break;
                cur += A[i][0] - dup.back();
                dup.pop_back();
            }
            seen.insert(A[i][1]);
            res = fmax(res, cur + 1L * seen.size() * seen.size());
        }
        return res;
    }
};",0
"class Solution {
    public int maxSum(int[] nums) {
    int ans = -1;
    Map<Integer,List<Integer>> ump = new HashMap<>();
    for(int i = 0; i < nums.length; ++i){
        int t = nums[i], maxDigit = 0;
        while(t != 0){ //evaluate max digit in the number
            maxDigit = Math.max(t%10, maxDigit);
            t = t/10;
        }
        if(!ump.containsKey(maxDigit)) ump.put(maxDigit, new ArrayList<>());
        ump.get(maxDigit).add(nums[i]); // add the number to the map 
    }
    for(Map.Entry<Integer, List<Integer>> entry: ump.entrySet()){
        entry.getValue().sort(Comparator.reverseOrder()); //to find max two number in each max digit 
        if(entry.getValue().size() >= 2) ans = Math.max(ans, entry.getValue().get(0) + entry.getValue().get(1)); //sum max two number and take max
    }
    return ans;
    }
}",0
"class Solution:
    def maxSum(self, nums: List[int]) -> int:
        max_by_digit = defaultdict(int)
        max_sum = -1

        for num in nums:
            digit = max(str(num))

            if digit in max_by_digit:
                max_sum = max(max_sum, max_by_digit[digit] + num)

            max_by_digit[digit] = max(max_by_digit[digit], num)

        return max_sum",0
"class Solution {
    public:
        int maxSum(vector<int>& nums) {
        int res = -1, max_num[10] = {};
        for (auto num : nums) {
            int max_d = 0;
            for (int v = num; v; v /= 10)
                max_d = max(max_d, v % 10);
            if (max_num[max_d])
                res = max(res, max_num[max_d] + num);
            max_num[max_d] = max(max_num[max_d], num);
        }
        return res;
    }
};",0
"class Solution {
    public String finalString(String s) {
        StringBuilder nm=new StringBuilder();
        for(char c:s.toCharArray())
        {
            if(c=='i')
            {
                nm.reverse();
            }
            else
            {
                nm.append(c);
            }
        }
        return nm.toString();
    }
}",0
"class Solution:
    def finalString(self, s: str) -> str:
        while ""i"" in s:
            index=s.index(""i"")

            #first half and second half
            first=s[:index][::-1]
            second=s[index+1:]

            s="""".join([first,second])
        return s",0
"class Solution {
public:
    string finalString(const string &s) {
        string a, b;
        for (char ch : s)
            if (ch == 'i')
                swap(a, b);
            else
                a += ch;
        return string(rbegin(b), rend(b)) + a;
    }
};",0
"class Solution {
    int minAbsoluteDifference(List<Integer> nums, int x) {
        int ans = Integer.MAX_VALUE;
        TreeSet<Integer> s = new TreeSet<>();
        for(int i = x; i < nums.size(); ++i){
            s.add(nums.get(i-x));
            Integer high = s.ceiling(nums.get(i)), low = s.floor(nums.get(i));
            if(high != null) ans = Math.min(ans, Math.abs(nums.get(i) - high));
            if(low != null) ans = Math.min(ans, Math.abs(nums.get(i) - low));
        }
        return ans;
    }
}",0
"class Solution:
  def minAbsoluteDifference(self, nums: List[int], x: int) -> int:
    if x == 0:
      return 0

    arr, best_dist = SortedList([]), float('inf')
    for i in range(x, len(nums)):
      arr.add(nums[i - x])
      v = nums[i]

      pos = arr.bisect_left(v)
      if pos < len(arr):
        best_dist = min(best_dist, abs(arr[pos] - v))
      if pos > 0:
        best_dist = min(best_dist, abs(arr[pos - 1] - v))
    
    return best_dist",0
"class Solution {
public:
    int minAbsoluteDifference(vector<int>& nums, int x) {
        int ans = INT_MAX;
        set<int> s;
        for(int i = x; i < nums.size(); ++i){
            s.insert(nums[i-x]);
            auto it = s.upper_bound(nums[i]);
            if(it != s.end()) ans = min(ans, abs(nums[i] - *it));
            if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));
        }
        return ans;
    }
};",0
"class Solution {
    public ListNode doubleIt(ListNode head) {
        if (head.val > 4)
            head = new ListNode(0, head);
        for(ListNode node = head; node != null; node = node.next) {
            node.val = (node.val * 2) % 10;
            if (node.next != null && node.next.val > 4)
                node.val++;
        }
        return head;
    }
}",0
"class Solution:
    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head.val > 4:
            head = ListNode(0, head)
        node = head
        while node:
            node.val = (node.val * 2) % 10
            if node.next and node.next.val > 4:
                node.val += 1
            node = node.next
        return head",0
"class Solution {
public:
    ListNode* doubleIt(ListNode* head) {
        if (head->val > 4)
            head = new ListNode(0, head);
        for(ListNode* node = head; node; node = node->next) {
            node->val = (node->val * 2) % 10;
            if (node->next && node->next->val > 4)
                node->val++;
        }
        return head;
    }
};",0
"class Solution {
    static final int MOD = 1000000007;

    public int maximumScore(List<Integer> nums, int k) {
        int n = nums.size();

        int upper = Collections.max(nums) + 1;

        boolean[] prime = new boolean[upper];
        int[] primeScore = new int[upper];
        Arrays.fill(prime, true);
        prime[0] = prime[1] = false;
        for (int i = 2; i < upper; i++) {
            if (prime[i]) {
                for (int j = i; j < upper; j += i) {
                    primeScore[j]++;
                    prime[j] = false;
                }
            }
        }

        int[] nextGreaterElement = new int[n];
        Arrays.fill(nextGreaterElement, n);
        Stack<Integer> s = new Stack<>();
        for (int i = n - 1; i >= 0; i--) {
            while (!s.empty() && primeScore[nums.get(i)] >= primeScore[nums.get(s.peek())]) {
                s.pop();
            }
            nextGreaterElement[i] = s.empty() ? n : s.peek();
            s.push(i);
        }

        int[] prevGreaterOrEqualElement = new int[n];
        Arrays.fill(prevGreaterOrEqualElement, -1);
        s = new Stack<>();
        for (int i = 0; i < n; i++) {
            while (!s.empty() && primeScore[nums.get(i)] > primeScore[nums.get(s.peek())]) {
                s.pop();
            }
            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.peek();
            s.push(i);
        }

        int res = 1;
        int[][] tuples = new int[n][2];
        for (int i = 0; i < n; i++) {
            tuples[i][0] = nums.get(i);
            tuples[i][1] = i;
        }
        Arrays.sort(tuples, new Comparator<int[]>() {
            public int compare(int[] a, int[] b) {
                return b[0] - a[0];
            }
        });
        for (int i = 0; i < n; i++) {
            int num = tuples[i][0];
            int idx = tuples[i][1];
            int operations = Math.min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k);
            res = (int)((1L * res * pow(num, operations)) % MOD);
            k -= operations;
            if (k == 0) {
                return res;
            }
        }

        return res;
    }

    public int pow(int x, int n) {
        int res = 1;
        while (n > 0) {
            if (n % 2 == 1) {
                res = (int)((1L * res * x) % MOD);
            }
            x = (int)((1L * x * x) % MOD);
            n /= 2;
        }
        return res;
    }
}",0
"class Solution: 
    MOD = 1000000007

    def maximumScore(self, nums: List[int], k: int) -> int:
        n = len(nums)

        upper = max(nums) + 1

        prime = [True]*upper
        prime[0] = prime[1] = False
        primeScore = [0]*upper
        for i in range(2, upper):
            if prime[i]:
                for j in range(i, upper, i):
                    primeScore[j] += 1
                    prime[j] = False

        nextGreaterElement = [n]*n
        s = []
        for i in range(n - 1, -1, -1):
            while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:
                s.pop()
            nextGreaterElement[i] = s[-1] if s else n
            s.append(i)

        prevGreaterOrEqualElement = [-1]*n
        s = []
        for i in range(n):
            while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:
                s.pop()
            prevGreaterOrEqualElement[i] = s[-1] if s else -1
            s.append(i)

        res = 1
        tuples = [[nums[i], i] for i in range(n)]
        tuples.sort(reverse=True)
        for num, idx in tuples:
            operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)
            res = (res * self.pow(num, operations)) % self.MOD
            k -= operations
            if k == 0:
                return res

        return res

    def pow(self, x: int, n: int) -> int:
        res = 1
        while n > 0:
            if n % 2 == 1:
                res = (res * x) % self.MOD
            x = (x * x) % self.MOD
            n //= 2
        return res",0
"class Solution {
public:
    const int MOD = 1000000007;

    int maximumScore(vector<int>& nums, int k) {
        int n = nums.size();

        int upper = *max_element(nums.begin(), nums.end()) + 1;

        vector<bool> prime(upper, true);
        prime[0] = prime[1] = false;
        vector<int> primeScore(upper, 0);
        for (int i = 2; i < upper; i++) {
            if (prime[i]) {
                for (int j = i; j < upper; j += i) {
                    primeScore[j]++;
                    prime[j] = false;
                }
            }
        }

        vector<int> nextGreaterElement(n, n);
        stack<int> s;
        for (int i = n - 1; i >= 0; i--) {
            while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {
                s.pop();
            }
            nextGreaterElement[i] = s.empty() ? n : s.top();
            s.push(i);
        }

        vector<int> prevGreaterOrEqualElement(n, -1);
        s = stack<int>();
        for (int i = 0; i < n; i++) {
            while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {
                s.pop();
            }
            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();
            s.push(i);
        }

        int res = 1;
        vector<pair<int, int>> tuples(n);
        for (int i = 0; i < n; i++) {
            tuples[i].first = nums[i];
            tuples[i].second = i;
        }
        sort(tuples.rbegin(), tuples.rend());
        for (const auto& [num, i] : tuples) {
            int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);
            res = (int)((1L * res * pow(num, operations)) % MOD);
            k -= operations;
            if (k == 0) {
                return res;
            }
        }

        return res;
    }

    int pow(int x, int n) {
        int res = 1;
        while (n > 0) {
            if (n % 2 == 1) {
                res = (int)((1L * res * x) % MOD);
            }
            x = (int)((1L * x * x) % MOD);
            n /= 2;
        }
        return res;
    }
};",0
"class Solution {
    public long findMaximumElegance(int[][] A, int k) {
        Arrays.sort(A, (a, b) -> b[0] - a[0]);
        long res = 0, cur = 0;
        List<Integer> dup = new ArrayList<>();
        Set<Integer> seen = new HashSet<>();
        for (int i = 0; i < A.length; ++i) {
            if (i < k) {
                if (seen.contains(A[i][1])) {
                    dup.add(A[i][0]);
                }
                cur += A[i][0];
            } else if (!seen.contains(A[i][1])) {
                if (dup.isEmpty()) break;
                cur += A[i][0] - dup.remove(dup.size() - 1);
            }
            seen.add(A[i][1]);
            res = Math.max(res, cur + 1L * seen.size() * seen.size());
        }
        return res;
    }
}",0
"class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        items = sorted(items, key=lambda v: -v[0])
        res = cur = 0
        A = []
        seen = set()
        for i, (p, c) in enumerate(items):
            if i < k:
                if c in seen:
                    A.append(p)
                cur += p
            elif c not in seen:
                if not A: break
                cur += p - A.pop()
            seen.add(c)
            res = max(res, cur + len(seen) * len(seen))
        return res",0
"class Solution {
public:
    long long findMaximumElegance(vector<vector<int>>& A, int k) {
        sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {
            return a[0] > b[0];
        });
        long long res = 0, cur = 0;
        vector<int> dup;
        unordered_set<int> seen;
        for (int i = 0; i < A.size(); ++i) {
            if (i < k) {
                if (seen.count(A[i][1])) {
                    dup.push_back(A[i][0]);
                }
                cur += A[i][0];
            } else if (seen.find(A[i][1]) == seen.end()) {
                if (dup.empty()) break;
                cur += A[i][0] - dup.back();
                dup.pop_back();
            }
            seen.insert(A[i][1]);
            res = fmax(res, cur + 1L * seen.size() * seen.size());
        }
        return res;
    }
};",0
"class Solution {
    public int maxSum(int[] nums) {
    int ans = -1;
    Map<Integer,List<Integer>> ump = new HashMap<>();
    for(int i = 0; i < nums.length; ++i){
        int t = nums[i], maxDigit = 0;
        while(t != 0){ //evaluate max digit in the number
            maxDigit = Math.max(t%10, maxDigit);
            t = t/10;
        }
        if(!ump.containsKey(maxDigit)) ump.put(maxDigit, new ArrayList<>());
        ump.get(maxDigit).add(nums[i]); // add the number to the map 
    }
    for(Map.Entry<Integer, List<Integer>> entry: ump.entrySet()){
        entry.getValue().sort(Comparator.reverseOrder()); //to find max two number in each max digit 
        if(entry.getValue().size() >= 2) ans = Math.max(ans, entry.getValue().get(0) + entry.getValue().get(1)); //sum max two number and take max
    }
    return ans;
    }
}",0
"class Solution:
    def maxSum(self, nums: List[int]) -> int:
        max_by_digit = defaultdict(int)
        max_sum = -1

        for num in nums:
            digit = max(str(num))

            if digit in max_by_digit:
                max_sum = max(max_sum, max_by_digit[digit] + num)

            max_by_digit[digit] = max(max_by_digit[digit], num)

        return max_sum",0
"class Solution {
    public:
        int maxSum(vector<int>& nums) {
        int res = -1, max_num[10] = {};
        for (auto num : nums) {
            int max_d = 0;
            for (int v = num; v; v /= 10)
                max_d = max(max_d, v % 10);
            if (max_num[max_d])
                res = max(res, max_num[max_d] + num);
            max_num[max_d] = max(max_num[max_d], num);
        }
        return res;
    }
};",0
"class Solution {
    public String finalString(String s) {
        StringBuilder nm=new StringBuilder();
        for(char c:s.toCharArray())
        {
            if(c=='i')
            {
                nm.reverse();
            }
            else
            {
                nm.append(c);
            }
        }
        return nm.toString();
    }
}",0
"class Solution:
    def finalString(self, s: str) -> str:
        while ""i"" in s:
            index=s.index(""i"")

            #first half and second half
            first=s[:index][::-1]
            second=s[index+1:]

            s="""".join([first,second])
        return s",0
"class Solution {
public:
    string finalString(const string &s) {
        string a, b;
        for (char ch : s)
            if (ch == 'i')
                swap(a, b);
            else
                a += ch;
        return string(rbegin(b), rend(b)) + a;
    }
};",0
"class Solution {
    int minAbsoluteDifference(List<Integer> nums, int x) {
        int ans = Integer.MAX_VALUE;
        TreeSet<Integer> s = new TreeSet<>();
        for(int i = x; i < nums.size(); ++i){
            s.add(nums.get(i-x));
            Integer high = s.ceiling(nums.get(i)), low = s.floor(nums.get(i));
            if(high != null) ans = Math.min(ans, Math.abs(nums.get(i) - high));
            if(low != null) ans = Math.min(ans, Math.abs(nums.get(i) - low));
        }
        return ans;
    }
}",0
"class Solution:
  def minAbsoluteDifference(self, nums: List[int], x: int) -> int:
    if x == 0:
      return 0

    arr, best_dist = SortedList([]), float('inf')
    for i in range(x, len(nums)):
      arr.add(nums[i - x])
      v = nums[i]

      pos = arr.bisect_left(v)
      if pos < len(arr):
        best_dist = min(best_dist, abs(arr[pos] - v))
      if pos > 0:
        best_dist = min(best_dist, abs(arr[pos - 1] - v))
    
    return best_dist",0
"class Solution {
public:
    int minAbsoluteDifference(vector<int>& nums, int x) {
        int ans = INT_MAX;
        set<int> s;
        for(int i = x; i < nums.size(); ++i){
            s.insert(nums[i-x]);
            auto it = s.upper_bound(nums[i]);
            if(it != s.end()) ans = min(ans, abs(nums[i] - *it));
            if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));
        }
        return ans;
    }
};",0
"class Solution {
    public ListNode doubleIt(ListNode head) {
        if (head.val > 4)
            head = new ListNode(0, head);
        for(ListNode node = head; node != null; node = node.next) {
            node.val = (node.val * 2) % 10;
            if (node.next != null && node.next.val > 4)
                node.val++;
        }
        return head;
    }
}",0
"class Solution:
    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head.val > 4:
            head = ListNode(0, head)
        node = head
        while node:
            node.val = (node.val * 2) % 10
            if node.next and node.next.val > 4:
                node.val += 1
            node = node.next
        return head",0
"class Solution {
public:
    ListNode* doubleIt(ListNode* head) {
        if (head->val > 4)
            head = new ListNode(0, head);
        for(ListNode* node = head; node; node = node->next) {
            node->val = (node->val * 2) % 10;
            if (node->next && node->next->val > 4)
                node->val++;
        }
        return head;
    }
};",0
"class Solution {
    static final int MOD = 1000000007;

    public int maximumScore(List<Integer> nums, int k) {
        int n = nums.size();

        int upper = Collections.max(nums) + 1;

        boolean[] prime = new boolean[upper];
        int[] primeScore = new int[upper];
        Arrays.fill(prime, true);
        prime[0] = prime[1] = false;
        for (int i = 2; i < upper; i++) {
            if (prime[i]) {
                for (int j = i; j < upper; j += i) {
                    primeScore[j]++;
                    prime[j] = false;
                }
            }
        }

        int[] nextGreaterElement = new int[n];
        Arrays.fill(nextGreaterElement, n);
        Stack<Integer> s = new Stack<>();
        for (int i = n - 1; i >= 0; i--) {
            while (!s.empty() && primeScore[nums.get(i)] >= primeScore[nums.get(s.peek())]) {
                s.pop();
            }
            nextGreaterElement[i] = s.empty() ? n : s.peek();
            s.push(i);
        }

        int[] prevGreaterOrEqualElement = new int[n];
        Arrays.fill(prevGreaterOrEqualElement, -1);
        s = new Stack<>();
        for (int i = 0; i < n; i++) {
            while (!s.empty() && primeScore[nums.get(i)] > primeScore[nums.get(s.peek())]) {
                s.pop();
            }
            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.peek();
            s.push(i);
        }

        int res = 1;
        int[][] tuples = new int[n][2];
        for (int i = 0; i < n; i++) {
            tuples[i][0] = nums.get(i);
            tuples[i][1] = i;
        }
        Arrays.sort(tuples, new Comparator<int[]>() {
            public int compare(int[] a, int[] b) {
                return b[0] - a[0];
            }
        });
        for (int i = 0; i < n; i++) {
            int num = tuples[i][0];
            int idx = tuples[i][1];
            int operations = Math.min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k);
            res = (int)((1L * res * pow(num, operations)) % MOD);
            k -= operations;
            if (k == 0) {
                return res;
            }
        }

        return res;
    }

    public int pow(int x, int n) {
        int res = 1;
        while (n > 0) {
            if (n % 2 == 1) {
                res = (int)((1L * res * x) % MOD);
            }
            x = (int)((1L * x * x) % MOD);
            n /= 2;
        }
        return res;
    }
}",0
"class Solution: 
    MOD = 1000000007

    def maximumScore(self, nums: List[int], k: int) -> int:
        n = len(nums)

        upper = max(nums) + 1

        prime = [True]*upper
        prime[0] = prime[1] = False
        primeScore = [0]*upper
        for i in range(2, upper):
            if prime[i]:
                for j in range(i, upper, i):
                    primeScore[j] += 1
                    prime[j] = False

        nextGreaterElement = [n]*n
        s = []
        for i in range(n - 1, -1, -1):
            while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:
                s.pop()
            nextGreaterElement[i] = s[-1] if s else n
            s.append(i)

        prevGreaterOrEqualElement = [-1]*n
        s = []
        for i in range(n):
            while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:
                s.pop()
            prevGreaterOrEqualElement[i] = s[-1] if s else -1
            s.append(i)

        res = 1
        tuples = [[nums[i], i] for i in range(n)]
        tuples.sort(reverse=True)
        for num, idx in tuples:
            operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)
            res = (res * self.pow(num, operations)) % self.MOD
            k -= operations
            if k == 0:
                return res

        return res

    def pow(self, x: int, n: int) -> int:
        res = 1
        while n > 0:
            if n % 2 == 1:
                res = (res * x) % self.MOD
            x = (x * x) % self.MOD
            n //= 2
        return res",0
"class Solution {
public:
    const int MOD = 1000000007;

    int maximumScore(vector<int>& nums, int k) {
        int n = nums.size();

        int upper = *max_element(nums.begin(), nums.end()) + 1;

        vector<bool> prime(upper, true);
        prime[0] = prime[1] = false;
        vector<int> primeScore(upper, 0);
        for (int i = 2; i < upper; i++) {
            if (prime[i]) {
                for (int j = i; j < upper; j += i) {
                    primeScore[j]++;
                    prime[j] = false;
                }
            }
        }

        vector<int> nextGreaterElement(n, n);
        stack<int> s;
        for (int i = n - 1; i >= 0; i--) {
            while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {
                s.pop();
            }
            nextGreaterElement[i] = s.empty() ? n : s.top();
            s.push(i);
        }

        vector<int> prevGreaterOrEqualElement(n, -1);
        s = stack<int>();
        for (int i = 0; i < n; i++) {
            while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {
                s.pop();
            }
            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();
            s.push(i);
        }

        int res = 1;
        vector<pair<int, int>> tuples(n);
        for (int i = 0; i < n; i++) {
            tuples[i].first = nums[i];
            tuples[i].second = i;
        }
        sort(tuples.rbegin(), tuples.rend());
        for (const auto& [num, i] : tuples) {
            int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);
            res = (int)((1L * res * pow(num, operations)) % MOD);
            k -= operations;
            if (k == 0) {
                return res;
            }
        }

        return res;
    }

    int pow(int x, int n) {
        int res = 1;
        while (n > 0) {
            if (n % 2 == 1) {
                res = (int)((1L * res * x) % MOD);
            }
            x = (int)((1L * x * x) % MOD);
            n /= 2;
        }
        return res;
    }
};",0
"class Solution {
    public long findMaximumElegance(int[][] A, int k) {
        Arrays.sort(A, (a, b) -> b[0] - a[0]);
        long res = 0, cur = 0;
        List<Integer> dup = new ArrayList<>();
        Set<Integer> seen = new HashSet<>();
        for (int i = 0; i < A.length; ++i) {
            if (i < k) {
                if (seen.contains(A[i][1])) {
                    dup.add(A[i][0]);
                }
                cur += A[i][0];
            } else if (!seen.contains(A[i][1])) {
                if (dup.isEmpty()) break;
                cur += A[i][0] - dup.remove(dup.size() - 1);
            }
            seen.add(A[i][1]);
            res = Math.max(res, cur + 1L * seen.size() * seen.size());
        }
        return res;
    }
}",0
"class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        items = sorted(items, key=lambda v: -v[0])
        res = cur = 0
        A = []
        seen = set()
        for i, (p, c) in enumerate(items):
            if i < k:
                if c in seen:
                    A.append(p)
                cur += p
            elif c not in seen:
                if not A: break
                cur += p - A.pop()
            seen.add(c)
            res = max(res, cur + len(seen) * len(seen))
        return res",0
"class Solution {
public:
    long long findMaximumElegance(vector<vector<int>>& A, int k) {
        sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {
            return a[0] > b[0];
        });
        long long res = 0, cur = 0;
        vector<int> dup;
        unordered_set<int> seen;
        for (int i = 0; i < A.size(); ++i) {
            if (i < k) {
                if (seen.count(A[i][1])) {
                    dup.push_back(A[i][0]);
                }
                cur += A[i][0];
            } else if (seen.find(A[i][1]) == seen.end()) {
                if (dup.empty()) break;
                cur += A[i][0] - dup.back();
                dup.pop_back();
            }
            seen.insert(A[i][1]);
            res = fmax(res, cur + 1L * seen.size() * seen.size());
        }
        return res;
    }
};",0
"class Solution {
    public int maxSum(int[] nums) {
    int ans = -1;
    Map<Integer,List<Integer>> ump = new HashMap<>();
    for(int i = 0; i < nums.length; ++i){
        int t = nums[i], maxDigit = 0;
        while(t != 0){ //evaluate max digit in the number
            maxDigit = Math.max(t%10, maxDigit);
            t = t/10;
        }
        if(!ump.containsKey(maxDigit)) ump.put(maxDigit, new ArrayList<>());
        ump.get(maxDigit).add(nums[i]); // add the number to the map 
    }
    for(Map.Entry<Integer, List<Integer>> entry: ump.entrySet()){
        entry.getValue().sort(Comparator.reverseOrder()); //to find max two number in each max digit 
        if(entry.getValue().size() >= 2) ans = Math.max(ans, entry.getValue().get(0) + entry.getValue().get(1)); //sum max two number and take max
    }
    return ans;
    }
}",0
"class Solution:
    def maxSum(self, nums: List[int]) -> int:
        max_by_digit = defaultdict(int)
        max_sum = -1

        for num in nums:
            digit = max(str(num))

            if digit in max_by_digit:
                max_sum = max(max_sum, max_by_digit[digit] + num)

            max_by_digit[digit] = max(max_by_digit[digit], num)

        return max_sum",0
"class Solution {
    public:
        int maxSum(vector<int>& nums) {
        int res = -1, max_num[10] = {};
        for (auto num : nums) {
            int max_d = 0;
            for (int v = num; v; v /= 10)
                max_d = max(max_d, v % 10);
            if (max_num[max_d])
                res = max(res, max_num[max_d] + num);
            max_num[max_d] = max(max_num[max_d], num);
        }
        return res;
    }
};",0
"class Solution {
    public String finalString(String s) {
        StringBuilder nm=new StringBuilder();
        for(char c:s.toCharArray())
        {
            if(c=='i')
            {
                nm.reverse();
            }
            else
            {
                nm.append(c);
            }
        }
        return nm.toString();
    }
}",0
"class Solution:
    def finalString(self, s: str) -> str:
        while ""i"" in s:
            index=s.index(""i"")

            #first half and second half
            first=s[:index][::-1]
            second=s[index+1:]

            s="""".join([first,second])
        return s",0
"class Solution {
public:
    string finalString(const string &s) {
        string a, b;
        for (char ch : s)
            if (ch == 'i')
                swap(a, b);
            else
                a += ch;
        return string(rbegin(b), rend(b)) + a;
    }
};",0
"class Solution {
    int minAbsoluteDifference(List<Integer> nums, int x) {
        int ans = Integer.MAX_VALUE;
        TreeSet<Integer> s = new TreeSet<>();
        for(int i = x; i < nums.size(); ++i){
            s.add(nums.get(i-x));
            Integer high = s.ceiling(nums.get(i)), low = s.floor(nums.get(i));
            if(high != null) ans = Math.min(ans, Math.abs(nums.get(i) - high));
            if(low != null) ans = Math.min(ans, Math.abs(nums.get(i) - low));
        }
        return ans;
    }
}",0
"class Solution:
  def minAbsoluteDifference(self, nums: List[int], x: int) -> int:
    if x == 0:
      return 0

    arr, best_dist = SortedList([]), float('inf')
    for i in range(x, len(nums)):
      arr.add(nums[i - x])
      v = nums[i]

      pos = arr.bisect_left(v)
      if pos < len(arr):
        best_dist = min(best_dist, abs(arr[pos] - v))
      if pos > 0:
        best_dist = min(best_dist, abs(arr[pos - 1] - v))
    
    return best_dist",0
"class Solution {
public:
    int minAbsoluteDifference(vector<int>& nums, int x) {
        int ans = INT_MAX;
        set<int> s;
        for(int i = x; i < nums.size(); ++i){
            s.insert(nums[i-x]);
            auto it = s.upper_bound(nums[i]);
            if(it != s.end()) ans = min(ans, abs(nums[i] - *it));
            if(it != s.begin()) ans = min(ans, abs(nums[i] - *prev(it)));
        }
        return ans;
    }
};",0
"class Solution {
    public ListNode doubleIt(ListNode head) {
        if (head.val > 4)
            head = new ListNode(0, head);
        for(ListNode node = head; node != null; node = node.next) {
            node.val = (node.val * 2) % 10;
            if (node.next != null && node.next.val > 4)
                node.val++;
        }
        return head;
    }
}",0
"class Solution:
    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head.val > 4:
            head = ListNode(0, head)
        node = head
        while node:
            node.val = (node.val * 2) % 10
            if node.next and node.next.val > 4:
                node.val += 1
            node = node.next
        return head",0
"class Solution {
public:
    ListNode* doubleIt(ListNode* head) {
        if (head->val > 4)
            head = new ListNode(0, head);
        for(ListNode* node = head; node; node = node->next) {
            node->val = (node->val * 2) % 10;
            if (node->next && node->next->val > 4)
                node->val++;
        }
        return head;
    }
};",0
"class Solution {
    static final int MOD = 1000000007;

    public int maximumScore(List<Integer> nums, int k) {
        int n = nums.size();

        int upper = Collections.max(nums) + 1;

        boolean[] prime = new boolean[upper];
        int[] primeScore = new int[upper];
        Arrays.fill(prime, true);
        prime[0] = prime[1] = false;
        for (int i = 2; i < upper; i++) {
            if (prime[i]) {
                for (int j = i; j < upper; j += i) {
                    primeScore[j]++;
                    prime[j] = false;
                }
            }
        }

        int[] nextGreaterElement = new int[n];
        Arrays.fill(nextGreaterElement, n);
        Stack<Integer> s = new Stack<>();
        for (int i = n - 1; i >= 0; i--) {
            while (!s.empty() && primeScore[nums.get(i)] >= primeScore[nums.get(s.peek())]) {
                s.pop();
            }
            nextGreaterElement[i] = s.empty() ? n : s.peek();
            s.push(i);
        }

        int[] prevGreaterOrEqualElement = new int[n];
        Arrays.fill(prevGreaterOrEqualElement, -1);
        s = new Stack<>();
        for (int i = 0; i < n; i++) {
            while (!s.empty() && primeScore[nums.get(i)] > primeScore[nums.get(s.peek())]) {
                s.pop();
            }
            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.peek();
            s.push(i);
        }

        int res = 1;
        int[][] tuples = new int[n][2];
        for (int i = 0; i < n; i++) {
            tuples[i][0] = nums.get(i);
            tuples[i][1] = i;
        }
        Arrays.sort(tuples, new Comparator<int[]>() {
            public int compare(int[] a, int[] b) {
                return b[0] - a[0];
            }
        });
        for (int i = 0; i < n; i++) {
            int num = tuples[i][0];
            int idx = tuples[i][1];
            int operations = Math.min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k);
            res = (int)((1L * res * pow(num, operations)) % MOD);
            k -= operations;
            if (k == 0) {
                return res;
            }
        }

        return res;
    }

    public int pow(int x, int n) {
        int res = 1;
        while (n > 0) {
            if (n % 2 == 1) {
                res = (int)((1L * res * x) % MOD);
            }
            x = (int)((1L * x * x) % MOD);
            n /= 2;
        }
        return res;
    }
}",0
"class Solution: 
    MOD = 1000000007

    def maximumScore(self, nums: List[int], k: int) -> int:
        n = len(nums)

        upper = max(nums) + 1

        prime = [True]*upper
        prime[0] = prime[1] = False
        primeScore = [0]*upper
        for i in range(2, upper):
            if prime[i]:
                for j in range(i, upper, i):
                    primeScore[j] += 1
                    prime[j] = False

        nextGreaterElement = [n]*n
        s = []
        for i in range(n - 1, -1, -1):
            while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:
                s.pop()
            nextGreaterElement[i] = s[-1] if s else n
            s.append(i)

        prevGreaterOrEqualElement = [-1]*n
        s = []
        for i in range(n):
            while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:
                s.pop()
            prevGreaterOrEqualElement[i] = s[-1] if s else -1
            s.append(i)

        res = 1
        tuples = [[nums[i], i] for i in range(n)]
        tuples.sort(reverse=True)
        for num, idx in tuples:
            operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)
            res = (res * self.pow(num, operations)) % self.MOD
            k -= operations
            if k == 0:
                return res

        return res

    def pow(self, x: int, n: int) -> int:
        res = 1
        while n > 0:
            if n % 2 == 1:
                res = (res * x) % self.MOD
            x = (x * x) % self.MOD
            n //= 2
        return res",0
"class Solution {
public:
    const int MOD = 1000000007;

    int maximumScore(vector<int>& nums, int k) {
        int n = nums.size();

        int upper = *max_element(nums.begin(), nums.end()) + 1;

        vector<bool> prime(upper, true);
        prime[0] = prime[1] = false;
        vector<int> primeScore(upper, 0);
        for (int i = 2; i < upper; i++) {
            if (prime[i]) {
                for (int j = i; j < upper; j += i) {
                    primeScore[j]++;
                    prime[j] = false;
                }
            }
        }

        vector<int> nextGreaterElement(n, n);
        stack<int> s;
        for (int i = n - 1; i >= 0; i--) {
            while (!s.empty() && primeScore[nums[i]] >= primeScore[nums[s.top()]]) {
                s.pop();
            }
            nextGreaterElement[i] = s.empty() ? n : s.top();
            s.push(i);
        }

        vector<int> prevGreaterOrEqualElement(n, -1);
        s = stack<int>();
        for (int i = 0; i < n; i++) {
            while (!s.empty() && primeScore[nums[i]] > primeScore[nums[s.top()]]) {
                s.pop();
            }
            prevGreaterOrEqualElement[i] = s.empty() ? -1 : s.top();
            s.push(i);
        }

        int res = 1;
        vector<pair<int, int>> tuples(n);
        for (int i = 0; i < n; i++) {
            tuples[i].first = nums[i];
            tuples[i].second = i;
        }
        sort(tuples.rbegin(), tuples.rend());
        for (const auto& [num, i] : tuples) {
            int operations = min((i - prevGreaterOrEqualElement[i]) * (nextGreaterElement[i] - i), k);
            res = (int)((1L * res * pow(num, operations)) % MOD);
            k -= operations;
            if (k == 0) {
                return res;
            }
        }

        return res;
    }

    int pow(int x, int n) {
        int res = 1;
        while (n > 0) {
            if (n % 2 == 1) {
                res = (int)((1L * res * x) % MOD);
            }
            x = (int)((1L * x * x) % MOD);
            n /= 2;
        }
        return res;
    }
};",0
"class Solution {
    public long findMaximumElegance(int[][] A, int k) {
        Arrays.sort(A, (a, b) -> b[0] - a[0]);
        long res = 0, cur = 0;
        List<Integer> dup = new ArrayList<>();
        Set<Integer> seen = new HashSet<>();
        for (int i = 0; i < A.length; ++i) {
            if (i < k) {
                if (seen.contains(A[i][1])) {
                    dup.add(A[i][0]);
                }
                cur += A[i][0];
            } else if (!seen.contains(A[i][1])) {
                if (dup.isEmpty()) break;
                cur += A[i][0] - dup.remove(dup.size() - 1);
            }
            seen.add(A[i][1]);
            res = Math.max(res, cur + 1L * seen.size() * seen.size());
        }
        return res;
    }
}",0
"class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        items = sorted(items, key=lambda v: -v[0])
        res = cur = 0
        A = []
        seen = set()
        for i, (p, c) in enumerate(items):
            if i < k:
                if c in seen:
                    A.append(p)
                cur += p
            elif c not in seen:
                if not A: break
                cur += p - A.pop()
            seen.add(c)
            res = max(res, cur + len(seen) * len(seen))
        return res",0
"class Solution {
public:
    long long findMaximumElegance(vector<vector<int>>& A, int k) {
        sort(A.begin(), A.end(), [](const vector<int>& a, const vector<int>& b) {
            return a[0] > b[0];
        });
        long long res = 0, cur = 0;
        vector<int> dup;
        unordered_set<int> seen;
        for (int i = 0; i < A.size(); ++i) {
            if (i < k) {
                if (seen.count(A[i][1])) {
                    dup.push_back(A[i][0]);
                }
                cur += A[i][0];
            } else if (seen.find(A[i][1]) == seen.end()) {
                if (dup.empty()) break;
                cur += A[i][0] - dup.back();
                dup.pop_back();
            }
            seen.insert(A[i][1]);
            res = fmax(res, cur + 1L * seen.size() * seen.size());
        }
        return res;
    }
};",0
